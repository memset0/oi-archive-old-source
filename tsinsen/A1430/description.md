<div id="pcont1" style="margin-top:20px; display:block;">

# 问题描述

<div class="pdcont">　　在一节IT课上Valera学习数据压缩。老师谈及了一种新的办法，现在我们将告诉你。<br/>
　　令{a1,a2……an}为一连串给定需要压缩的台词的序列。现在我们假设所有的台词具有相同的长度且仅有数字0和1构成。让我们定义比较函数：<br/>
　　l f(空序列)=空串<br/>
　　l f(s)=s<br/>
　　l f(s1,s2)=最小长度的有一个前缀等于s1并且有一个后缀等于s2的字符串。例如，f(001,011)=0011,f(111,011)=111011<br/>
　　l f(a1,a2,……,an)=f(f(a1,a2,……,an-1),an),例如，f(000,000,111)=f(f(000,000),111)=f(000,111)=000111.<br/>
　　Valera面对一个真实的考验：他要把给定的序列{a1,a2……an}分为两个子序列{b1,b2……bk}和{c1,c2……cm}，m+k=n,使得S=|f(b1,b2……bk)|+|f(c1,c2……cm)|取得合法的最小值。|p|是字符串p的长度。<br/>
　　注意在子序列中改变台词的相对顺序是不允许的。而其中一个子序列为空是被允许的。开始的序列中的每个字符串都应完全属于一个序列。序列b,c的元素在原序列a中不需要连续。i.e:序列b,c的元素可以在原序列中交替出现。<br/>
　　帮助Valera找到I最小的合法值。</div>
# 输入格式

<div class="pdcont">　　输入数据第一行包含一个整数n—字符串的数量。接下来n行序列中的元素—长度在1~20内的由数字0和1组成的字符串。输入的第i+1行包含序列中的第i个元素。序列中的元素仅由一个换行隔开。保证每一行长度相同。</div>
# 输出格式

<div class="pdcont">　　输出一个单独的数—S的最小合法值。</div>
# 样例输入

<div class="pddata">3<br/>
01<br/>
10<br/>
01</div>
# 样例输出

<div class="pddata">4</div>
# 样例输入

<div class="pddata">4<br/>
000<br/>
111<br/>
110<br/>
001</div>
# 样例输出

<div class="pddata">8</div>
# 样例输入

<div class="pddata">5<br/>
10101<br/>
01010<br/>
11111<br/>
01000<br/>
10010</div>
# 样例输出

<div class="pddata">17</div>
# 注意

<div class="pdcont">　　样例的详细解答：<br/>
　　l 最优解是令一个子序列为空，第二个等于给定的序列|f(01,10,01)|=|f(f(01,10)01)|=|f(010,01)|=|0101|=4<br/>
　　l 最优解是：b={000,001},c={111,110}.S=|f(000,001)|+|f(111,110)|=|0001|+|1110|=8.<br/>
　　l 最优解是：b={10101,01010,01000},c={11111,10010}.S=|10101000|+|111110010|=17.</div>

</div>