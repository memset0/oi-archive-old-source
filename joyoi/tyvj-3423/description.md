# 

 
 # 题目描述 
<p>
　　求一个图的最小生成树。这个图边较少，但点较多（n <= 5000），宜用kruskal算法。<br><br></p> 

 
 # 输入格式 
<p>
　　第一行一个数n，表示无向图的顶点的数量，接下来从第2行到第n+1行，每行有n个数（0表示相应点之间无边直接相连，不为0表示相应点之间有边直接相连，其值即为相连边的权值），形成一个n*n的矩阵，用以表示这个无向图。<br></p> 

 
 # 输出格式 
<p>
　　一行，仅一个数，表示最小生成树的边权值和。</p> 

 
 # 提示 
<p>
基于贪心的kuruskal算法求最小生成树，算法思路如下：<br>　　每次选不属于同一连通分量(保证无圈)且边权值最小的2个顶点，将边加入最小生成树集合中，并将所在的2个连通分量合并，直到只剩一个连通分量。<br>算法实现：<br>　　1、将边按非降序排列；<br>　　while 合并次数　少于　顶点数-1　begin<br>　　　　取一条边(u,v)(因为已经排序，所以必为最小)<br>　　　　if 顶点u,v不属于同一连通分量 then<br>　　　　　　合并u,v所在的连通分量，（注：此处使用并查集实现，以提高效率！）<br>　　　　　　//如果需要输出选用的边，输出边(u,v)。<br>　　　　　　合并次数增1；tot=tot+w(u,v)<br>　　end;<br>　　算法结束：tot为最小生成树的总权值 </p> 
# 样例数据
<style>
        table,table tr th, table tr td { border:1px solid #0094ff; }
        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   
    </style>
<table>
	<tr>
		<td>输入样例</td>
		<td>输出样例</td>
	</tr>
<tr><td>8
0 9 4 6 0 0 0 0
9 0 0 2 0 0 0 0
4 0 0 1 9 0 0 0
6 2 1 0 0 2 6 0
0 0 9 0 0 3 0 0
0 0 0 2 3 0 0 7
0 0 0 6 0 0 0 2
0 0 0 0 0 7 2 0
</td><td>自己算。</td></tr></table>
