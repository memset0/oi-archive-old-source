{"title":"Nearest Common Ancestors（最近公共祖先）","time_limit":1000,"memory_limit":64,"url":"http://www.joyoi.cn/problem/tyvj-3239","statement":[{"title":"","format":"markdown","require":["katex"],"content":"\n# \n\n \n # 题目描述 \n<p>\n最近公共祖先（lca.pas/c/cpp)\r<br>\r<br>【问题描述】\r<br>\r<br>　 　 有根树是一个在计算机科学和工程学中众所周知的数据结构。如下图所示的例子：\r<br>\r<br><br><center><img src=\"/source/joyoi/tyvj-3239/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzIzOS9wcm9ibGVtc19pbWFnZXMvMTc3NC9wMS5naWY=.gif\"></img></center>\r<br>\r<br>　 　 在上图，每个结点用1-16中的一个整数标记。结点8是这棵树的根。\r<br>　 　 一个结点x是一个结点y的祖先当且仅当结点x是在根和结点y的路径上。例如，结点4是结点16的祖先，结点10也是结点16的祖先。实际上，结点8，4和12都是结点16的祖先。记住每个结点都是它自己的祖先。结点8，4，6和7都是结点7的祖先。\r<br>　 　 一个结点x被称做结点y和z的公共祖先当且仅当x都是y和z的祖先。因此，结点8 和4是结点16和7的公共祖先。\r<br>　 　 一个结点x被称做结点y和z的最近公共祖先当且仅当x是y和z的一个公共祖先且在y和z的所有公共祖先中是最近的。所以，结点16和7的最近公共祖先是结点4，因为结点4比结点8更接近结点16和7。\r<br>\r<br>　 　 在其它例子中，结点2和3的最近公共祖先结点10，结点6和13的最近公共祖先是结点8，结点4和12的最近公共祖先是结点4。在最后的一个例子中，如果y是z的一个祖先，那么y和z的最近公共祖先是y。\r<br>\r<br>　 　 写一个程序找出在一棵树中两个不同结点的最近公共祖先。\r<br>\r<br></p> \n\n \n # 输入格式 \n<p>\n输入包括T组数据。第一行是一个整数T。\r<br>对每组数据，第一行是一个整数N，表示这棵树的结点数，其中2<=N<=10，000。\r<br>这些结点标记为1，2，…，N。\r<br>接下来的N-1行包括一对整数，代表一条边，第一个数是第二个数的父亲。\r<br>保证N个结点恰好有N-1条边。\r<br>最后的一行包括两个不同的整数，表示要求最近公共祖先的两个不同结点\r<br></p> \n\n \n # 输出格式 \n<p>\n对每组数据输出一行，包括一个表示所求的两个不同结点的最近公共祖先的整数\r<br></p> \n\n \n # 提示 \n<p>\n本题数据不完整，请在本系统测试通过后到http://poj.org/problem?id=1330 提交完整测试！</p> "},{"title":"样例数据","format":"markdown","require":["katex"],"content":"<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>输入样例</td>\n\t\t<td>输出样例</td>\n\t</tr>\n<tr><td>2\r\n16\r\n1 14\r\n8 5\r\n10 16\r\n5 9\r\n4 6\r\n8 4\r\n4 10\r\n1 13\r\n6 15\r\n10 11\r\n6 7\r\n10 2\r\n16 3\r\n8 1\r\n16 12\r\n16 7\r\n5\r\n2 3\r\n3 4\r\n3 1\r\n1 5\r\n3 5\r\n\r\n</td><td>4\r\n3</td></tr></table>\n\n"}]}