{"title":"[JSOI2008]火星人的研究","time_limit":1000,"memory_limit":128,"url":"http://www.joyoi.cn/problem/tyvj-1823","statement":[{"title":"","format":"markdown","require":["katex"],"content":"\n# \n\n \n # 题目描述 \n火星人是一种好奇心很大的生物。最近，火星人对字符串产生了浓厚的兴趣。他们研究了字符串的LCP：<BR>\t<BR>\t对于字符串str[1..n]，LCP(i,&nbsp;j)为str[i..n]与str[j..n]这两个字符串的公共前缀长。<BR>\t<BR>\t例如str=\"madamimadam\"：<BR>\t<BR><img src=\"/source/joyoi/tyvj-1823/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMTgyMy9Qcm9ibGVtSW1nLzE4MjMuanBn.jpg\" border=0 align=middle><BR>\t<BR>\t有LCP(1,&nbsp;7)&nbsp;=&nbsp;LCP(\"madamimadam\",&nbsp;\"madam\")&nbsp;=&nbsp;5<BR>\tLCP(4,&nbsp;8)&nbsp;=&nbsp;LCP(\"amimadam\",&nbsp;\"adam\")&nbsp;=&nbsp;1<BR>\tLCP(10,11)&nbsp;=&nbsp;LCP(\"am\",&nbsp;\"m\")&nbsp;=&nbsp;0<BR>\t<BR>\t后来，火星人发现，如果进行了后缀排序，就能够很快地求LCP，同样，如果能很快地求出字符串的LCP，也可以高效地把所有后缀排序。不过事情总不是想象的那么简单，地球人JS总是喜欢测试火星人的智商：他会在火星人把字符串的后缀排序以后，修改原来的字符串，导致火星人的工作全盘浪费。<BR>\t<BR>\t于是火星人请到了聪明的你，设计一个程序，对给出的字符串能够支持以下三种操作：<BR>\t<BR>\t1、求LCP(i,&nbsp;j)<BR>\t2、将第i个位置的字符修改<BR>\t3、在第i个位置后插入一个字符<BR>\t<BR>\t火星人很害怕被地球人耻笑，所以希望你的算法能有很高的执行效率。 \n\n \n # 输入格式 \n输入文件第一行为一个字符串（仅包含小写字母）。<BR>\t接下来的一行的整数Q代表操作的个数（1&nbsp;≤Q&nbsp;&nbsp;≤150000）。<BR>\t接下来Q行表示了待执行的操作。<BR>\tQ&nbsp;i&nbsp;j表示求LCP(i,&nbsp;j)的数值<BR>\tR&nbsp;i&nbsp;char表示将第i位置的字符替换成小写字母char<BR>\tI&nbsp;i&nbsp;char表示在第i个字符后插入小写字母char \n\n \n # 输出格式 \n对于每一个Q&nbsp;i&nbsp;j，输出一行为LCP(i,&nbsp;j)的数值。 \n\n \n # 提示 \n对于20%的数据，最终字符串的长度不超过1000。<BR>\t对于另外30%的数据中不含有插入操作。<BR>\t对于100%的数据，最终字符串的长度不超过100000。<BR>\t对于100%的数据，替换字符的次数不超过100000。<BR>\t对于100%的数据，询问LCP的次数不超过10000。 "},{"title":"# 样例数据","format":"markdown","require":["katex"],"content":"<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>输入样例</td>\n\t\t<td>输出样例</td>\n\t</tr>\n<tr><td>madamimadam\r\n7\r\nQ 1 7\r\nQ 4 8\r\nQ 10 11\r\nR 3 a\r\nQ 1 7\r\nI 10 a\r\nQ 2 11</td><td>5\r\n1\r\n0\r\n2\r\n1</td></tr></table>\n\n"}]}