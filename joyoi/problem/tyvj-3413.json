{"title":"求最小生成树（prim）","time_limit":1000,"memory_limit":64,"url":"http://www.joyoi.cn/problem/tyvj-3413","statement":[{"title":"","format":"markdown","require":["katex"],"content":"\n# \n\n \n # 题目描述 \n<p>\n　　求一个图的最小生成树。这个图边较多，但点较少，宜用prim算法。\r<br></p> \n\n \n # 输入格式 \n<p>\n　　第一行一个数n，表示无向图的顶点的数量（n<=1000），接下来从第2行到第n+1行，每行有n个数（0表示相应点之间无边直接相连，不为0表示相应点之间有边直接相连，其值即为相连边的权值），形成一个n*n的矩阵，用以表示这个无向图。</p> \n\n \n # 输出格式 \n<p>\n　　一行，仅一个数，表示最小生成树的边权值和。\r<br></p> \n\n \n # 提示 \n<p>\n基于贪心的prime求最小生成树算法，思想如下：\r<br>从某个点出发，构建生成树，不断的将距离生成树最近的点拉入到生成树中。\r<br>具体算法过程：\r<br>    先对某个点进行标记，将这个节点相连的所有边标记为待处理边\r<br>     while 已标记的节点数 < 图中的节点总数    begin\r<br>        从待处理边集中寻找一条最短的，\r<br>        用新找到的最短边的另一头节点作为新节点，更新与该节点相关的所有连边的信息：\r<br>               如果与新节点相连的边另一头节点已经标记则从待处理边集中剔除该边\r<br>               如果与新节点相连的边另一头节点没有标记过，则将该连边加入到待处理边集中\r<br>        将找到的最短边所连接的没标记的点标记起来，表示该点已经进入生成树；\r<br>      end</p> "},{"title":"# 样例数据","format":"markdown","require":["katex"],"content":"<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>输入样例</td>\n\t\t<td>输出样例</td>\n\t</tr>\n<tr><td>8\r\n0 9 4 6 0 0 0 0\r\n9 0 0 2 0 0 0 0\r\n4 0 0 1 9 0 0 0\r\n6 2 1 0 0 2 6 0\r\n0 0 9 0 0 3 0 0\r\n0 0 0 2 3 0 0 7\r\n0 0 0 6 0 0 0 2\r\n0 0 0 0 0 7 2 0\r\n</td><td>自己算。</td></tr></table>\n\n"}]}