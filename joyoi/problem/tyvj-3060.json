{"title":"取余运算","time_limit":1000,"memory_limit":64,"url":"http://www.joyoi.cn/problem/tyvj-3060","statement":[{"title":"","format":"markdown","require":["katex"],"content":"\n# \n\n \n # 题目描述 \n<p>\n　　输入b，p，k的值，求b^p mod k的值。其中b，p，k*k为长整型数。</p> \n\n \n # 输入格式 \n<p>\n2 10 9</p> \n\n \n # 输出格式 \n<p>\n2^10 mod 9=7（只输出结果）</p> \n\n \n # 提示 \n<p>\n【算法分析】\r<br>　　本题主要的难点在于数据规模很大(b, p都是长整型数)，对于b^p显然不能死算，那样的话时间复杂度和编程复杂度都很大。\r<br>　　下面先介绍一个原理：a*b mod k＝(a mod k)*(b mod k)mod k。显然有了这个原理，就可以把较大的幂分解成较小的，因而免去高精度计算等复杂过程。那么怎样分解最有效呢?显然对于任何一个自然数P，有p＝2*p div 2+p mod 2，如19＝2*19 div 2十19 mod 2＝2*9+1，利用上述原理就可以把b的19次方除以k的余数转换为求b的9次方除以k的余数，即b^19=(b^2)*9+1＝b*b^9*b^9，再进一步分解下去就不难求得整个问题的解。\r<br>　　这是一个典型的分治问题，具体实现的时候是用递推的方法来处理的，如p=19，有19=2*9+1，9=2*4+1，4=2*2+0，2=2*1+0，1＝2*0+1，反过来，我们可以从0出发，通过乘以2再加上一个0或1而推出1，2，4，9，19，这样就逐步得到了原来的指数，进而递推出以b为底，依次以这些数为指数的自然数除以k的余数。不难看出这里每一次乘以2后要加的数就是19对应的二进制数的各位数字，即1，0，0，1，1，而19＝(10011)2，求解的过程也就是将二进制数还原为十进制数的过程。\r<br>　　具体实现请看下面的程序，程序中用数组binary存放p对应的二进制数，总位数为len，binary[1]存放最底位。变量rest记录每一步求得的余数。\r<br>\r<br></p> "},{"title":"# 样例数据","format":"markdown","require":["katex"],"content":"<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>输入样例</td>\n\t\t<td>输出样例</td>\n\t</tr>\n<tr><td>2 10 9</td><td>7</td></tr></table>\n\n"}]}