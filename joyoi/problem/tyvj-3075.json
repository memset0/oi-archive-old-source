{"title":"医院设置","time_limit":1000,"memory_limit":64,"url":"http://www.joyoi.cn/problem/tyvj-3075","statement":[{"title":"","format":"markdown","require":["katex"],"content":"\n# \n\n \n # 题目描述 \n<p>\n　　设有一棵二叉树，如图5-1：\r<br><br><center><img src=\"/source/joyoi/tyvj-3075/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzA3NS9wcm9ibGVtc19pbWFnZXMvMTIzMC8xLmJtcA==.bmp\"></img></center>\r<br>　　其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为l。如上图中，若医院建在：\r<br></p> \n\n \n # 输入格式 \n<p>\n　　第一行一个整数n，表示树的结点数。(n≤100)\r<br>　　接下来的n行每行描述了一个结点的状况，包含三个整数，整数之间用空格(一个或多个)分隔，其中：第一个数为居民人口数；第二个数为左链接，为0表示无链接；第三个数为右链接。\r<br></p> \n\n \n # 输出格式 \n<p>\n　　一个整数，表示最小距离和。</p> \n\n \n # 提示 \n<p>\n　　本题的求解任务十分明了：求一个最小路径之和。\r<br>　　根据题意，对n个结点，共有n个路径之和：用记号Si表示通向结点i的路径之和，则 ，其中Wj为结点j的居民数，g(i,j)为结点j到结点i的最短路径长度。下面表中反映的是样例的各项数据：\r<br>j\r<br>g(i,j)\r<br>i\t1\t2\t3\t4\t5\tSi\r<br>1\t0\t1\t1\t2\t2\t0×13+1×4+1×12+2×20+2×40=136\r<br>2\t1\t0\t2\t3\t3\t1×13+0×4+2×12+3×20+3×40=217\r<br>3\t1\t2\t0\t1\t1\t1×13+2×4+0×12+1×20+1×40=81\r<br>4\t2\t3\t1\t0\t2\t2×13+3×4+1×12+0×20+2×40=130\r<br>5\t2\t3\t1\t2\t0\t2×13+3×4+1×12+2×20+0×40=90\r<br> \r<br>　　从表中可知S3=81最小，医院应建在3号居民点，使得所有居民走的路径之和为最小。\r<br>　　由此可知，本题的关键是求g[i,j]，即图中任意两点间的最短路径长度。\r<br>　　求任意两点间的最短路径采用下面的弗洛伊德（Floyd）算法。\r<br>　　（1）数据结构：\r<br>　　　　w:array[1..100]of longing;　　　　　　　描述个居民点人口数\r<br>　　　　g:array[1..100, 1..100]of longint　　　　初值为图的邻接矩阵，最终为最短路径长度\r<br>　　（2）数据的读入：\r<br>　　　　本题数据结构的原形为二叉树，数据提供为孩子标识法，分支长度为1，建立带权图的邻接矩阵，分下面两步：\r<br>　　　　　①g[i,j]←Max　　　　　　　{Max为一较大数，表示结点i与j之间无直接相连边}\r<br>　　　　　②读入n个结点信息：\r<br>　　for i:=1 to n do\r<br>　　　begin\r<br>　　　　　g[i,j]:=0;\r<br>　　　　　readln(w[i],l,r);\r<br>　　　　　if l>0 then begin\r<br>　　　　　　　　 g[i,l]:=l;\t　　g[l,i]:=l\r<br>　　　　　 end;\r<br>　　if r>0 then begin\r<br>　　　　g[i,r]:=l;\t　　　g[r,i]:=l\r<br>　　end;\r<br>　　（3）弗洛伊德算法求任意两点间的最短路径长度\r<br>　　　　for k:=1 to n do\r<br>　　　　　　for i:=1 to n do\r<br>　　　　　　　　if i<>k then for j:=1 to n do\r<br>　　　　　　　　　　if (i<>j)and(k<>j)and(g[i,k]+g[k,j]<g[i,j])  then g[i,j]:=g[i,k]+g[k,j];\r<br>　　（4）求最小的路程和min\r<br>　　　　min:=max longint;\r<br>　　　　for i:=1 to n do\r<br>　　　　　begin\r<br>　　　　　　　sum:=0;\r<br>　　　　　　　for j:=1 to n do sum:=sum+w[i]*g[i,j];\r<br>　　　　　　　if sum<min then min:=sum;\r<br>　　　　　end;\r<br>　　（5）输出\r<br>　　　　　writeln(min);\r<br></p> "},{"title":"# 样例数据","format":"markdown","require":["katex"],"content":"<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>输入样例</td>\n\t\t<td>输出样例</td>\n\t</tr>\n<tr><td>5\t\t\t\t\t\t\r\n13 2 3\r\n4 0 0\r\n12 4 5\r\n20 0 0\r\n40 0 0\r\n</td><td>81</td></tr></table>\n\n"}]}