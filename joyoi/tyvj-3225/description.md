# 

 
 # 题目描述 
<p>
【线段树二维拓展】（理论基础）<br>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>　　线段树处理的是线性统计问题，而我们往往会遇到一些平面统计问题和空间统计问题。因此我们需要推广线段树，使它变成能解决平面问题的“矩形树”和能解决空间问题的“方块树”。<br>　　将一维线段树改成二维线段树，有两种方法。一种就是给原来线段树中的每个结点都加多一棵线段树，即“树中有树”。如下图：<br><br><center><img src="/source/joyoi/tyvj-3225/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzIyNS9wcm9ibGVtc19pbWFnZXMvMTczNS8xLmJtcA==.bmp"></img></center><br><br>　　例如在主线段树的结点[1,3]中，线段[3,5]表示的就是矩形(1,3,3,5) ｛注：本文用(x1,y1,x2,y2)表示左下角顶点坐标为(x1,y1),右上角顶点坐标为(x2,y2)的矩形｝。容易算出，用这种方法构造一棵矩形(x1,y1,x2,y2)的线段树需要的空间为 ,即空间复杂度为 ，其中Long_x，Long_y分别表示矩形的长和宽。相应地，时间复杂度为 。其中n为操作数。由于这种线段树有两层，处理起来较麻烦。<br><br><center><img src="/source/joyoi/tyvj-3225/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzIyNS9wcm9ibGVtc19pbWFnZXMvMTczNS8yLmJtcA==.bmp"></img></center><br><br><br><br>　　另一种方式是直接将原来线段树结点中的线段变成矩形。即每个结点代表一个矩形。因此矩形树用的是四分的思想，每个矩形分割为4个子矩形。矩形(x1,y1,x2,y2)的4个儿子分别为：<br>(x1,y1,(x1+x2)/2,(y1+y2)/2)、<br>((x1+x2)/2,y1,x2,(y1+y2)/2)、<br>(x1,(y1+y2)/2,(x1+x2)/2,y2)、<br>((x1+x2)/2 ,(y1+y2)/2,x2,y2)<br>　　例如下图就是一棵以矩形(1,1,4,3)为根的矩形树：<br><br><center><img src="/source/joyoi/tyvj-3225/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzIyNS9wcm9ibGVtc19pbWFnZXMvMTczNS8zLmJtcA==.bmp"></img></center><br><br><br><br><br>　　易知，以(x1,y1,x2,y2)为根的矩形树的空间复杂度也是 。但由于它只有一层，处理起来比第一种方法方便。而且在这种矩形树中，标记思想依然适用。而第一种方法中，标号思想在主线段树上并不适用，只能在第二层线段树上使用。但是这种方法的时间复杂度可能会达到 。比起第一种来就差了不少。<br>　　对于多维的问题，第一种方法几乎不可能使用。因此我们可以仿照第二种方法。例如对于n维的问题。我们构造以(a1,a2,a3,….,an,b1,b2,b3,….,bn)为根的线段树，其中(a1,a2,a3….,an)表示的是左下角的坐标，(b1,b2,b3,….,bn)表示的是右上角的坐标。构造的时候用的就不是二分，四分了，而是2n分，构造出一棵2n叉树。结点的个数变为2n×(b1-a1)×(b2-a2)×………×(bn-an)。<br>　　[小结]<br>　　作为解决统计类问题的利器，线段树在改进和推广之后，做到了高效地解决更多的问题。因其适用范围广和实现上的方便，线段树不失为一个优秀的方法。但线段树还是有一些缺陷的，在某些问题中，可以利用[矩形切割]改进效率，关于[矩形切割]的理论请参考国家集训队员论文《解决动态统计问题的两把利刃——剖析线段树与矩形切割》，作者：薛矛。<br><br>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br><br><br>[问题描述]square<br>　　给你一个n*n的方格棋盘，初始时每个格子都是白色。现在要刷M次黑色或白色的油漆。每次刷漆的区域都是一个平行棋盘边缘的矩形区域。<br>　　输入n,m,以及每次刷漆的区域和颜色，输出刷了m次之后棋盘上还有多少个棋格是白色。<br></p> 

 
 # 输入格式 
<p>
</p> 

 
 # 输出格式 
<p>
</p> 

 
 # 提示 
<p>
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>　　首先我们从简单入手，考虑一维的问题。即对于一个长度为n的白色线段，对它进行M次修改（每次更新某一子区域的颜色）。问最后还剩下的白色区域有多长。<br>　　对于这个问题，很容易想到建立一棵线段树的模型。<br>　　对于这个问题，在线段树中增添一个域Tree[v].white，记录该区间当前有多少部分是白色。然后再进行线段的插入和颜色统计。单次操作的复杂度都是O(logn)<br>　　算法的总时间复杂度是O(Mlogn)<br>　　那么原来的问题怎么解决呢？<br>　　为了适应原问题的特殊性，我们需要把线段树进行调整，即首先在横坐标上建立线段树，它的每个节点是一棵建立在纵坐标上的线段树（即树中有树）。<br>　　我们称之为二维线段树。<br>　　二维线段树的操作完全类同于一维线段树。<br>　　二维线段树上单次的插入（删除、查找、改值等）操作的复杂度都是O((logn)^2)。<br>　　将二维线段数应用到原问题当中，总的时间复杂度是O(Mlog2n)<br>　　还有一种结构比较简单的二维线段树，就是每个节点不再是区间，而是一个子平面。大家可以自己去实现一下，比较一下这两种构造方法的异同。<br>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br></p> 
# 样例数据
<style>
        table,table tr th, table tr td { border:1px solid #0094ff; }
        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   
    </style>
<table>
	<tr>
		<td>输入样例</td>
		<td>输出样例</td>
	</tr>
<tr><td></td><td></td></tr></table>
