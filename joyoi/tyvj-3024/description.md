# 

 
 # 题目描述 
<p>
　　一个正整数一般可以分为几个互不相同的自然数的和，如3=1+2，4=1+3，5＝1+4=2+3，6=1+5＝2+4，…。<br>　　现在你的任务是将指定的正整数n分解成若干个互不相同的自然数的和，且使这些自然数的乘积最大。<br></p> 

 
 # 输入格式 
<p>
　　只一个正整数n，(3≤n≤10000)。</p> 

 
 # 输出格式 
<p>
　　第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。<br>　　第二行是最大的乘积。<br></p> 

 
 # 提示 
<p>
【算法分析】<br>　　初看此题，很容易想到用回溯法进行搜索，但是这里的n范围比较大，最多到10000，如果盲目搜索，运行时间比较长，效率很低，对于部分数据可能得到结果，对于大部分数据会超时或栈溢出。<br>先来看看几个n比较小的例子，看能否从中找出规律：<br>n　　　　分解方案　　　最大的乘积<br>5　　　　2　3　　　　　6<br>6　　　　2　4　　　　　8<br>7　　　　3　4　　　　　12<br>8　　　　3　5　　　　　15<br>9　　　　2　3　4　　　　24<br>10　　　　2　3　5　　　30<br>　　可以发现，将n分解成a1, a2, a3, a4,…, am这m个自然数，该序列为从2开始的一串由小到大的自然数，如果a1为1，则对乘积没有影响，而且使n减少，没有实际意义，只有特殊情况如n为3、4时才可能用上。<br>　　设h>＝5，可以证明当将h拆分为两个不相同的部分并且两部分都大于1时两部分的乘积大于h。证明如下：<br>　　将h分为两部分：a，h-a其中2<＝a<h/2，两部分的乘积为a*(h-a)。<br>　　a*(h-a)-h＝h*a-a*a-h＝h*(a-1)-a*a<br>　　因为h>2*a，所以a*(h-a)-h>2*a*(a-1)-a*a=a*a-2*a=a*(a-2)<br>　　又因为a>＝2，所以a*(a-2)>=0，所以a*(h-a)-h>O即a*(h-a)>h。<br>　　从上面的证明可以看出，对于指定的正整数，如果其大于等于5，将它拆分为不同的部分后乘积变大，对于中间结果也是如此。因此可以将指定的n，依次拆成a1+a2+a3+a4+…+am，乘积最大。<br>　　现在的问题是如何拆分才能保证n＝a1+a2+a3+a4+…+am呢?<br>　　可以先这样取：当和不足n时，a1取2，a2取3，…，am-1取m，即从2开始按照自然数的顺序取数，最后剩余的数给am，如果am<=am-1，此时am跟前面的数字出现了重复，则把am从后面开始平均分布给前面的m-1个数。为什么要从后面开始往前呢?同样是考虑数据不出现重复的问题，如果是从前面往后面来平均分配，如2加上1以后变成3，就跟后面的已有的3出现了重复。这样操作到底是否正确、是否能保证乘积最大呢?还要加以证明。证明过程如下：<br>　　设两个整数a，b的和为2s，且a<>b，设a＝s-1，则b＝s+1，a*b=(s-1)*(s+1)=s2-1，如果a=s-2，则b＝s+2，a*b＝(s-2)*(s+2)＝s2-4。<br>　　a-b的绝对值越小，乘积的常数项越大，即乘积越大，上面的序列a1, a2, a3, a4, …, am正好满足了a-b的绝对值最小。但是还要注意两个特例就是n=3和n=4的情况，它们的分解方案分别为1，2和1，3，乘积分别为2和3。以n=10为例，先拆分为：10=2+3+4+1，最后一项为1，比4小，将其分配给前面的一项，得到10=2+3+5，所以最大的乘积为2*3*5＝30。以n=20为例，拆分为：20=2+3+4+5+6，正好是连续自然数的和，所以最大乘积为2*3*4*5*6=720。再以n=26为例，先拆分为：26=2+3+4+5+6+6，因为最后一项为6，不比最后第二项大，所以将其平均分给前面的项，优先考虑后面的项，即前面的4项各分到1，笫5项6分到2，最后是26＝3+4+5+6+8，所以最大的乘积为3*4*5*6*8＝2880。由于n可能大到10000，分解之后的各项乘积位数比较多，超过普通的数据类型的位数，所以要用到高精度运算来进行整数的乘法运算，将结果保存在数组里。<br>本题的贪心策略就是：<br>　　要使乘积最大，尽可能地将指定的n(n>4)拆分成从2开始的连续的自然数的和，如果最后有剩余的数，将这个剩余的数在优先考虑后面项的情况下平均分给前面的各项。<br>　　基本算法描述如下：<br>（1）拆分过程<br>　　拆分的数a先取2；<br>　　　　当n>a时做<br>　　　　　Begin<br>　　　　　　　选择a作为一项；<br>　　　　　　　a增加1；<br>　　　　　　　n减少a；<br>　　　　　End；<br>　　　　如果n>0，那么将n从最后一项开始平均分给各项；<br>　　　如果n还大于0，再从最后一项开始分一次；<br>（2）求乘积<br>　　　设置一个数组来存放乘积，初始状态位数为1，结果为1；<br>　　　将上面拆分的各项依次跟数组各项相乘并考虑进位；<br><br></p> 
# 样例数据
<style>
        table,table tr th, table tr td { border:1px solid #0094ff; }
        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   
    </style>
<table>
	<tr>
		<td>输入样例</td>
		<td>输出样例</td>
	</tr>
<tr><td>10</td><td>2 3 5
30</td></tr></table>
