# 

 
 # 题目描述 
<p>
最近公共祖先（lca.pas/c/cpp)<br><br>【问题描述】<br><br>　 　 有根树是一个在计算机科学和工程学中众所周知的数据结构。如下图所示的例子：<br><br><br><center><img src="/source/joyoi/tyvj-3239/img/aHR0cDovL3d3dy5qb3lvaS5jbi9wcm9ibGVtL3R5dmotMzIzOS9wcm9ibGVtc19pbWFnZXMvMTc3NC9wMS5naWY=.gif"></img></center><br><br>　 　 在上图，每个结点用1-16中的一个整数标记。结点8是这棵树的根。<br>　 　 一个结点x是一个结点y的祖先当且仅当结点x是在根和结点y的路径上。例如，结点4是结点16的祖先，结点10也是结点16的祖先。实际上，结点8，4和12都是结点16的祖先。记住每个结点都是它自己的祖先。结点8，4，6和7都是结点7的祖先。<br>　 　 一个结点x被称做结点y和z的公共祖先当且仅当x都是y和z的祖先。因此，结点8 和4是结点16和7的公共祖先。<br>　 　 一个结点x被称做结点y和z的最近公共祖先当且仅当x是y和z的一个公共祖先且在y和z的所有公共祖先中是最近的。所以，结点16和7的最近公共祖先是结点4，因为结点4比结点8更接近结点16和7。<br><br>　 　 在其它例子中，结点2和3的最近公共祖先结点10，结点6和13的最近公共祖先是结点8，结点4和12的最近公共祖先是结点4。在最后的一个例子中，如果y是z的一个祖先，那么y和z的最近公共祖先是y。<br><br>　 　 写一个程序找出在一棵树中两个不同结点的最近公共祖先。<br><br></p> 

 
 # 输入格式 
<p>
输入包括T组数据。第一行是一个整数T。<br>对每组数据，第一行是一个整数N，表示这棵树的结点数，其中2<=N<=10，000。<br>这些结点标记为1，2，…，N。<br>接下来的N-1行包括一对整数，代表一条边，第一个数是第二个数的父亲。<br>保证N个结点恰好有N-1条边。<br>最后的一行包括两个不同的整数，表示要求最近公共祖先的两个不同结点<br></p> 

 
 # 输出格式 
<p>
对每组数据输出一行，包括一个表示所求的两个不同结点的最近公共祖先的整数<br></p> 

 
 # 提示 
<p>
本题数据不完整，请在本系统测试通过后到http://poj.org/problem?id=1330 提交完整测试！</p> 
# 样例数据
<style>
        table,table tr th, table tr td { border:1px solid #0094ff; }
        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   
    </style>
<table>
	<tr>
		<td>输入样例</td>
		<td>输出样例</td>
	</tr>
<tr><td>2
16
1 14
8 5
10 16
5 9
4 6
8 4
4 10
1 13
6 15
10 11
6 7
10 2
16 3
8 1
16 12
16 7
5
2 3
3 4
3 1
1 5
3 5

</td><td>4
3</td></tr></table>
