{"title":"【WC2015】混淆与破解","time_limit":1000,"memory_limit":256,"url":"http://uoj.ac/problem/72","statement":[{"title":"题目描述","format":"html","require":["katex"],"content":"\n<p>小强和阿米巴是好朋友。</p>\n<p>阿米巴研发出了一套相当高端的图片识别系统，并把它写成了一个手机app。这个识别系统具备特殊的识别能力，比如说，它能够识别一张图片里是否有萌萌的小狗。</p>\n<p>这个app由两个模块组成，特征提取模块和分类模块。每当小强拍摄一张图片，特征提取模块就从中提取出一个长度为 $n$ 的 01 串并存储起来。当小强希望进行识别的时候，分类模块就会根据提取出的 01 串进行分类（即，输出一个 $0$ 或者 $1$ 的答案）。</p>\n<p>为了保护分类算法，阿米巴的这个 app 是经过加密处理的。经过对阿米巴的死缠烂打，小强弄明白了这个分类算法的工作原理。</p>\n<p>分类模块会从输入的这个 $n$ 位 01 串中恢复出 $m$ 位的“有效信息”。每个“有效信息” 都是经过某些输入变量的异或。之后，分类模块会利用这些 “有效信息” 进行运算来得到真正的结果。为了进一步加密，阿米巴还会加入 “噪声”。所谓 “噪声”，是指这个分类模块会故意按一定的比例将结果反转。小强拿到的可能是经过了反转的结果。</p>\n<p>举个例子，分类模块的算法步骤可能是这样的：</p>\n<pre><code class=\"sh_php\">function f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])</code></pre>\n<p>其中 <samp>x[]</samp> 是一个 01 串，<samp>x[i]</samp> 表示其中的第 $i$ 位，即一个 $0$ 或 $1$ 的函数。</p>\n<p><samp>g(x[])</samp> 是某个在大多数情况下返回 $0$，偶尔返回 $1$ 的函数。$h$ 是某个关于 <samp>z[]</samp> 的函数，其返回值为 $0$ 或 $1$。</p>\n<p><samp>z[0]</samp>, <samp>z[1]</samp>, <samp>z[2]</samp> 就是 “有效信息”。</p>\n<p>为了让小强无法从app中看出算法，这个算法被进行了混淆。为了方便起见，我们把混淆之后的算法叫做“混淆版算法”。混淆版算法的代码共有 $Q$ 行，它的每一行都是这个样子：</p>\n<pre><code class=\"sh_php\">y[u] = (not (y[v] and y[s])) xor y[d] xor y[e]</code></pre>\n<p>其中 <samp>y[]</samp> 是一个长度为 $L$ 的 01 数组；<samp>xor</samp> 表示异或，<samp>and</samp> 表示与，<samp>not</samp> 表示非。$u, v, s, d, e$ 是这一行的参数。初始的时候，<samp>y[0]～y[n - 1]</samp> 里面放置了 <samp>x[0]～x[n - 1]</samp> 这 $n$ 个输入位，其他地方都是 $0$。执行完这 $Q$ 行代码之后，<samp>y[0]</samp> 这个位就是输出。</p>\n<p>对于阿米巴的这种以损失性能为代价进行加密的行径，小强感到很愤怒。于是，小强打算从混淆版算法中破解出阿米巴的分类算法。为了方便起见，我们把破解得到的算法叫做“破解版算法”。小强希望你能够帮他破解出：</p>\n<ol><li>如何提取有效信息。这个可以表述为 $m$ 个 $\\{0, 1, \\dots, n - 1\\}$ 的子集，每个子集对应了一个有效信息是从哪几个输入位异或得到的；</li>\n<li>把这 $m$ 位有效信息映射到分类结果上的函数 $h$。该函数用一个长度为 $2^m$，每一位均为 $0$ 或 $1$ 的查找表表示；这 $2^m$ 位分别对应了 $m$ 位有效信息每一种可能的情况。</li>\n</ol><p>当然，这种破解算法是不唯一的，即，可能会有多种有效信息提取方法和查找表的组合。你只需要给出其中的一种即可。</p>\n<p>阿米巴保证，引入的噪声比例不超过 $p$。即，你需要求出的破解版算法，和混淆版算法至少在 $2^n(1 - p)$ 个不同输入上得到的结果是一样的；并且阿米巴保证这样的算法是存在的。</p>\n<p>同时，阿米巴也保证，这 $m$ 个有效信息都是必须的，即，$h$ 无法化简为少于 $m$ 个输入的函数。</p>\n"},{"title":"输入格式","format":"html","require":["katex"],"content":"\n\n<p>第一行包含 $4$ 个整数 $n, m, L, Q$。</p>\n<p>接下来 $Q$ 行，每行包含 $5$ 个整数 $u, v, s, d, e$，表示每行的参数。</p>\n"},{"title":"输出格式","format":"html","require":["katex"],"content":"\n\n<p>先输出 $m$ 行，每行包含 $1$ 个 $n$ 位 01 串，表示每个有效信息是由哪些输入位异或得到的。其中 $1$ 表示包含该输入位，$0$ 表示不包含。</p>\n<p>接下来输出一行一个长度为 $2^m$ 的 01 串，表示 $h$ 函数的查找表。查找表中的项按字典序进行排列。即，先排第一个有效信息是 $0$ 的，再排第一个有效信息是 $1$ 的。排第一个有效信息是 $0$ 的项的时候，先排第二个有效信息是 $0$ 的，再排第二个有效信息是 $1$ 的，以此类推。</p>\n"},{"title":"样例一","format":"html","require":["katex"],"content":"\n\n<h4>input</h4>\n<pre>3 2 4 1\n0 1 2 2 2\n\n</pre>\n\n<h4>output</h4>\n<pre>001\n010\n1110\n\n</pre>\n\n<h4>explanation</h4>\n<p>样例输入等价于如下代码</p>\n<pre><code class=\"sh_php\">y[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]</code></pre>\n<p>其中 <samp>x[0..n-1]</samp> 表示 01 串 $x$ 的第 $0$ 位到第 $n - 1$ 位。</p>\n<p>在这段代码中，每一种输入对应的输出如下：</p>\n<div class=\"table-responsive\">\n<table class=\"table table-bordered table-text-center table-vertical-middle\"><tbody><tr><td>input</td>\n<td>000</td>\n<td>001</td>\n<td>010</td>\n<td>011</td>\n<td>100</td>\n<td>101</td>\n<td>110</td>\n<td>111</td>\n</tr><tr><td>output</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr></tbody></table></div>\n\n<p>样例输出是一种破解方案，等价于如下代码：</p>\n<pre><code class=\"sh_php\">input x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])</code></pre>\n<p>$h$ 函数的输入和输出有如下对应关系：</p>\n<div class=\"table-responsive\">\n<table class=\"table table-bordered table-text-center table-vertical-middle\"><tbody><tr><td><samp>z[]</samp></td>\n<td>00</td>\n<td>01</td>\n<td>10</td>\n<td>11</td>\n</tr><tr><td><samp>h(z[])</samp></td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr></tbody></table></div>\n\n<p>可以发现，对于每一种输入，破解版算法和混淆版算法的输出是相同的。</p>\n"},{"title":"样例二","format":"html","require":["katex"],"content":"\n\n<p>见样例数据下载。</p>\n"},{"title":"限制与约定","format":"html","require":["katex"],"content":"\n\n<p>对于 10% 的数据，$m = 1$，$p = 0$；</p>\n<p>对于另外 30% 的数据，$m = 1$；</p>\n<p>对于另外 20% 的数据，$m = 2$；</p>\n<p>对于另外 20% 的数据，$m = 3$；</p>\n<p>对于另外 20% 的数据，$m = 4$。</p>\n<p>对于所有的数据，$1 \\leq n \\leq 64$，$1 \\leq L \\leq 256$，$1 \\leq Q \\leq 1024$，$0 \\leq p \\leq 0.01$，$0 \\leq u, v, s, d, e &lt; L$（注意，输入中并没有把 $p$ 的值给你）。</p>\n<p><strong>时间限制：</strong>$1\\texttt{s}$</p>\n<p><strong>空间限制：</strong>$256\\texttt{MB}$</p>\n"},{"title":"提示","format":"html","require":["katex"],"content":"\n\n<p>使用位运算一次在多个输入上求出函数值可以极大的加速你的程序。</p>\n"},{"title":"下载","format":"html","require":["katex"],"content":"\n\n<p><a href=\"/download.php?type=problem&amp;id=72\">样例数据下载</a></p>\n\n"}]}