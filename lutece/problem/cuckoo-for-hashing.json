{"title":"Cuckoo for Hashing","time_limit":1000,"memory_limit":64,"url":"https://acm.uestc.edu.cn/problem/cuckoo-for-hashing/description","statement":[{"title":"Content","format":"markdown","require":["katex"],"content":"\nAn integer hash table is a data structure that supports insert, delete and lookup of integer values in\nconstant time. Traditional hash structures consist of an array (the *hash table*) of some size $n$, and a\n*hash function* $f(x)$ which is typically $f(x) = x\\ \\rm mod$ $n$. To insert a value $x$ into the table, you compute\nits *hash value* $f(x)$ which serves as an index into the hash table for the location to store $x$. For example,\nif $x = 1234$ and the hash table has size $101$, then $1234$ would be stored in location $22 = 1234\\rm\\ mod$ $101$.\nOf course, it's possible that some other value is already stored in location $22$ ($x = 22$ for example),\nwhich leads to a collision. Collisions can be handled in a variety of ways which you can discuss with\nyour faculty advisor on the way home from the contest.\n\nCuckoo hashing is a form of hashing that employs two hash tables $T\\_1$ and $T\\_2$, each with its own hash\nfunction $f\\_1(x)$ and $f\\_2(x)$. Insertion of a value $x$ proceeds as follows: you first try to store $x$ in $T\\_1$ using\n$f\\_1(x)$. If that location is empty, then simply store $x$ there and you're done. Otherwise there is a collision\nwhich must be handled. Let $y$ be the value currently in that location. You replace $y$ with $x$ in $T\\_1$, and\nthen try to store $y$ in $T\\_2$ using $f\\_2(y)$. Again, if this location is empty, you store y there and you're\ndone. Otherwise, replace the value there (call it $z$) with $y$, and now try to store $z$ back in $T\\_1$ using\n$f\\_1(z)$, and so on. This continues, bouncing back and forth between the two tables until either you find\nan empty location, or until a certain number of swaps have occurred, at which point you rehash both\ntables (again, something to discuss with your faculty advisor). For the purposes of this problem, this\nlatter occurrence will never happen, i.e., the process should always continue until an empty location is\nfound, which will be guaranteed to happen for each inserted value.\n\nGiven the size of the two tables and a series of insertions, your job is to determine what is stored in\neach of the tables.\n\n(For those interested, cuckoo hashing gets its name from the behavior of the cuckoo bird, which is\nknown to fly to other bird's nests and lay its own eggs in it alongside the eggs already there. When\nthe larger cuckoo chick hatches, it pushes the other chicks out of the nest, thus getting all the food for\nitself. Gruesome but efficient.)\n"},{"title":"Standard Input","format":"markdown","require":["katex"],"content":"\nInput for each test case starts with $3$ positive integers $n\\_1$ $n\\_2$ $m$, where $n\\_1$ and $n\\_2$ are the sizes of the\ntables $T\\_1$ and $T\\_2$ (with $n\\_1, n\\_2\\leq 1000$ and $n\\_1\\neq n\\_2$) and $m$ is the number of inserts. Following this\nwill be $m$ integer values which are the values to be inserted into the tables. All of these values will be\nnon-negative. Each table is initially empty, and table $T\\_i$ uses the hash function $f\\_i(x) = x\\rm\\ mod$ $n\\_i$\n. A\nline containing $3$ zeros will terminate input.\n"},{"title":"Standard Output","format":"markdown","require":["katex"],"content":"\nFor each test case, output the non-empty locations in $T\\_1$ followed by the non-empty locations in $T\\_2$.\nUse one line for each such location and the form `i:v`, where $i$ is the index location of the table, and $v$\nis the value stored there. Output values in each table from lowest index to highest. If either table is\nempty, output nothing for that table.\n"},{"title":"Samples","format":"markdown","require":["katex"],"content":"\n<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>Input</td>\n\t\t<td>Output</td>\n\t</tr>\n<tr><td>5 7 4\n8 18 29 4\n6 7 4\n8 18 29 4\n1000 999 2\n1000\n2000\n0 0 0</td><td>Case 1:\nTable 1\n3:8\n4:4\nTable 2\n1:29\n4:18\nCase 2:\nTable 1\n0:18\n2:8\n4:4\n5:29\nCase 3:\nTable 1\n0:2000\nTable 2\n1:1000</td></tr></table>\n\n"}]}