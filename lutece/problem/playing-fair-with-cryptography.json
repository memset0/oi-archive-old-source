{"title":"Playing Fair with Cryptography","time_limit":1000,"memory_limit":64,"url":"https://acm.uestc.edu.cn/problem/playing-fair-with-cryptography/description","statement":[{"title":"# Content","format":"markdown","require":["katex"],"content":"\nEncryption is the process of taking plaintext and producing the corresponding *ciphertext*. One method\nto do this is the Playfair cipher. This cipher was invented by (who else) Charles Wheatstone in the\n$1850$'s (but got its name from one of its most ardent promoters, the Scottish scientist Lyon Playfair).\nUnlike many substitution ciphers, the Playfair cipher does not encrypt single letters at a time, but\ngroups of two letters called *digraphs*. The encryption process uses a $5\\times 5$ grid generated by a secret\nkey known only to the two parties using the cipher (hopefully). The grid is generated as follows: You\nwrite the letters of the key, one letter per square row-wise in the grid starting at the top. Any repeated\nletters in the key are skipped. After this is done, the remaining unused letters in the alphabet are placed\nin order in the remaining squares, with I and J sharing the same square. For example, if the key was\n`ECNA PROGRAMMING CONTEST`, the generated square would look like the following:\n\n<p class=\"text-center\"><img src=\"/source/lutece/playing-fair-with-cryptography/img/aHR0cHM6Ly9hY20udWVzdGMuZWR1LmNuL21lZGlhL2ltYWdlL3Byb2JsZW0vbmV3LzIwMTQwNTEwMTgxMzA5MjkyMjUucG5n.png\" alt=\"title\"></p>\n\nYou encrypt a digraph using the following rules:\n1. If both letters are in the same row, replace each with the letter to its immediate right (wrapping\naround at the end). For example, using the above grid the plaintext digraph `DS` is encrypted as\n`FB`, and `AP` is encrypted as `PE`.\n2. If both letters are in the same column, replace each with the letter immediately below it (again\nwrapping around at the bottom). For example, `PF` is encrypted as `IU` (or `JU`), and `WO` is\nencrypted as `CS`.\n3. Otherwise, `slide` the first character across its row until it is in the same column as the second\ncharacter, and do the same for the second character. The two characters you end up on are the\nencrypted characters of the digraph. If you view the original digraph as corners of a rectangle in\nthe grid, you are replacing them with the characters in the other two corners. For example, `TU`\nis encrypted as `FH`, `UT` is encrypted as `HF`, and `ZC` is encrypted as `WP`.\n\nWhat happens when the digraph contains the same letter twice? In the original Playfair cipher you\ninsert the letter `X` between the two letters and continue encrypting. You also use an extra `X` at the\nend of the plaintext if you have an odd number of letters. Thus the plaintext `OOPS` would first be\nchanged to the digraphs `OX`, `OP` and `SX` and then would be encrypted as `GWICBW` (using\nthe grid above). Note that the plaintext `POOS` would not need any added letters since the two `O`s\ndo not appear in the same digraph.\n\nWe'll modify the Playfair cipher in one simple way: Instead of always using `X` as the inserted letter,\nuse `A` the\f first time an insertion is needed, then `B` the next time, and so on (though you should never\nuse `J` as an inserted letter; just go from `I` to `K`). Once you hit `Z`, you go back to using `A`. If the\ninserted letter would result in a digraph with the same two letters, you just skip to the next inserted\nletter. For example, `OOPS` would now become the digraph stream `OA`, `OP`, `SB` before being\nencrypted, and the plaintext `AABCC` would become the digraph stream `AB`, `AB`, `CD`, `CE`.\nGiven a key and plaintext, you are to generate the corresponding ciphertext.\n"},{"title":"# Standard Input","format":"markdown","require":["katex"],"content":"\nThe input file will start with an integer $n$ indicating the number of problem instances. Each instance\nconsists of two lines, the first containing the key and the second the plaintext to encrypt. Both of\nthese may contain upper- and lower-case letters, as well as spaces and non-alphabetic characters (both\nof which should be ignored). For simplicity, the letters `j` and `J` will never appear in any key or\nplaintext.\n"},{"title":"# Standard Output","format":"markdown","require":["katex"],"content":"\nFor each problem instance, output the case number followed by the corresponding ciphertext using\nupper-case letters with no space. Always use the letter `I` instead of `J` in the ciphertext.\n"},{"title":"# Samples","format":"markdown","require":["katex"],"content":"\n<style>\n        table,table tr th, table tr td { border:1px solid #0094ff; }\n        table { width: 200px; min-height: 25px; line-height: 25px; text-align: center; border-collapse: collapse;}   \n    </style>\n<table>\n\t<tr>\n\t\t<td>Input</td>\n\t\t<td>Output</td>\n\t</tr>\n<tr><td>1\nECNA Programming Contest 2013\nThis is the easy problem!</td><td>Case 1: HVOFOFHVCPCPDWEIGSHNGD</td></tr></table>\n\n"}]}