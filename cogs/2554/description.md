# 题目描述


<h3>
【题目描述】<br/>
</h3>
<p>
为什么说本题是福利呢？因为这是一道非常直白的可持久化线段树的练习题，目的并不是虐人，而是指导你入门可持久化数据结构。
</p>
<p>
线段树有个非常经典的应用是处理RMQ问题，即区间最大/最小值询问问题。现在我们把这个问题可持久化一下:
</p>
<p>
Q k l r 查询数列在第k个版本时，区间[l, r]上的最大值
</p>
<p>
M k p v 把数列在第k个版本时的第p个数修改为v，并产生一个新的数列版本
</p>
<p>
最开始会给你一个数列，作为第1个版本。
</p>
<p>
每次M操作会导致产生一个新的版本。修改操作可能会很多呢，如果每次都记录一个新的数列，空间和时间上都是令人无法承受的。所以我们需要可持久化数据结构:
</p>
<p>
<img alt="" src="/upload/image/20161116/20161116151606_65054.jpg"/> 
</p>
<p>
对于最开始的版本1，我们直接建立一颗线段树，维护区间最大值。
</p>
<p>
修改操作呢？我们发现，修改只会涉及从线段树树根到目标点上一条树链上logn个节点而已，其余的节点并不会受到影响。所以对于每次修改操作，我们可以只重建修改涉及的节点即可。就像这样:
</p>
<p>
<img alt="" src="/upload/image/20161116/20161116151646_11588.png"/> 
</p>
<p>
需要查询第k个版本的最大值，那就从第k个版本的树根开始，像查询普通的线段树一样查询即可。
</p>
<p>
要计算好所需空间哦
</p>
<h3>
【输入格式】
</h3>
<p>
第一行两个整数N, Q。N是数列的长度，Q表示询问数
</p>
<p>
第二行N个整数，是这个数列
</p>
<p>
之后Q行，每行以0或者1开头，0表示查询操作Q，1表示修改操作M，格式为
</p>
<p>
0 k l r 查询数列在第k个版本时，区间[l, r]上的最大值 或者
</p>
<p>
1 k p v 把数列在第k个版本时的第p个数修改为v，并产生一个新的数列版本
</p>
<h3>
【输出格式】
</h3>
<p>
对于每个M询问，输出正确答案
</p>
<h3>
【样例输入】<br/>
</h3>
<p>
4 5
</p>
<p>
1 2 3 4
</p>
<p>
0 1 1 4
</p>
<p>
1 1 3 5
</p>
<p>
0 2 1 3
</p>
<p>
0 2 4 4
</p>
<p>
0 1 2 4
</p>
<h3>
【样例输出】
</h3>
<p>
4
</p>
<p>
5
</p>
<p>
4
</p>
<p>
4
</p>
<h3>
【提示】
</h3>
<h1>
样例解释
</h1>
<p>
序列版本1: 1 2 3 4
</p>
<p>
查询版本1的[1, 4]最大值为4
</p>
<p>
修改产生版本2: 1 2 5 4
</p>
<p>
查询版本2的[1, 3]最大值为5
</p>
<p>
查询版本1的[4, 4]最大值为4
</p>
<p>
查询版本1的[2, 4]最大值为4
</p>
<h1>
数据范围
</h1>
<p>
N &lt;= 10000 Q &lt;= 100000
</p>
<p>
对于每次询问操作的版本号k保证合法，
</p>
<p>
区间[l, r]一定满足1 &lt;= l &lt;= r &lt;= N
</p>
<h3>
【来源】
</h3>
<p>
lj出题人: sxysxy。原题见: http://syzoj.com/problem/247
</p>
