# 题目描述


<p>
题目描述：
</p>
<p>
给定一棵有根树，树根为1
</p>
<p>
一开始树上所有节点都是白色的，要求你维护以下操作：
</p>
<p>
1、C 将树上所有黑色节点变成白色
</p>
<p>
2、M u 将u节点染黑
</p>
<p>
3、Q u 查询u和所有黑色节点的所有LCA的深度最大的点的编号
</p>
<p>
LCA定义为两个点的最近公共祖先
</p>
<p>
<br/>
</p>
<p>
输入格式：
</p>
<p>
第一行输入n，m表示节点总数和操作总数
</p>
<p>
以下n-1行每行u，v描述树上的一条边的两个端点
</p>
<p>
以下m行每行描述一个询问如题所示
</p>
<p>
n,m&lt;=2000000
</p>
<p>
<br/>
</p>
<p>
输出格式：
</p>
<p>
对于每个Q询问输出相应的答案
</p>
<p>
如果没有LCA的话输出-1
</p>
<p>
<br/>
</p>
<p>
输入样例：
</p>
<p>
<br/>
</p>
<p>
10 10
</p>
<p>
1 2
</p>
<p>
1 3
</p>
<p>
2 4
</p>
<p>
3 5
</p>
<p>
4 6
</p>
<p>
3 7
</p>
<p>
4 8
</p>
<p>
7 9
</p>
<p>
8 10
</p>
<p>
M 9
</p>
<p>
M 9
</p>
<p>
M 6
</p>
<p>
Q 10
</p>
<p>
Q 5
</p>
<p>
M 9
</p>
<p>
C
</p>
<p>
Q 6
</p>
<p>
M 4
</p>
<p>
M 5
</p>
<p>
<br/>
</p>
<p>
输出样例：
</p>
<p>
4
</p>
<p>
3
</p>
<p>
-1
</p>
<p>
<br/>
</p>
<p>
提示：
</p>
<p>
注意输入数据较大，推荐使用读入优化
</p>
<p>
由于cojs评测机的问题，可能会爆栈，所以请在main函数的开头加入如下程序：
</p>
<p>
<br/>
</p>
<p>
int __size__=128&lt;&lt;20;
</p>
<p>
char *__p__=(char*)malloc(__size__)+__size__;
</p>
<p>
__asm__(&#34;movl %0, %%esp\n&#34;::&#34;r&#34;(__p__));
</p>
<p>
注意上述代码会占用你128MB的空间，请自行修改，测试数据大约开到70MB就可以了
</p>
<p>
本题开了标程两倍的时限，而且是黑白树系列的某道题的加强版，原做法是难以通过的
</p>
<p>
本题的做法是本人自己想出来的，如果有更好的做法，欢迎与我联系
</p>
<p>
本来想强制在线的，但是为了更好的算法的出现就没有强制 强制在线
</p>
