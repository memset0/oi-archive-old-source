{"title":"[国家集训队 2011] Crash的文明世界","time_limit":12000,"memory_limit":512,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vyzSNkUUU","statement":[{"title":"# 题目描述","format":"html","require":["katex"],"content":"\n\n<div class=\"content\">\n<!--begin main-->\n<!-- InstanceBeginEditable name=\"content\" -->\n<h3>\n【试题来源】\n</h3>\n<div id=\"psrc\" style=\"margin-top:20px;display:block;\">\n<div class=\"pdcont\">\n2011中国国家集训队命题答辩\n</div>\n</div>\n<div id=\"pinputs\" style=\"display:none;\">\n<div class=\"pdsec\">\n输入数据\n</div>\n<div class=\"pdcont\">\n<span class=\"notice\"> 这是一道提交答案的试题，下面给出了该题的输入数据：</span> \n</div>\n<div id=\"inputlist\" class=\"pddata\">\n</div>\n</div>\n<div id=\"pcont1\" style=\"margin-top:20px;display:block;\">\n<h3>\n【问题描述】\n</h3>\n<div class=\"pdcont\">\nCrash小朋友最近迷上了一款游戏——文明5(Civilization V)。在这个游戏中，玩家可以建立和发展自己的国家，通过外交和别的国家交流，或是通过战争征服别的国家。<br/>\n现在Crash已经拥有了一个N个城市的国家，这些城市之间通过道路相连。由于建设道路是有花费的，因此Crash只修建了N-1条道路连接这些城市，不过可以保证任意两个城市都有路径相通。<br/>\n在游戏中，Crash需要选择一个城市作为他的国家的首都，选择首都需要考虑很多指标，有一个指标是这样的：<br/>\n<img src=\"/upload/image/20141217/20141217170221_94257.bmp\" alt=\"\"/><br/>\n其中S(i)表示第i个城市的指标值，dist(i, j)表示第i个城市到第j个城市需要经过的道路条数的最小值，k为一个常数且为正整数。<br/>\n因此Crash交给你一个简单的任务：给出城市之间的道路，对于每个城市，输出这个城市的指标值，由于指标值可能会很大，所以你只需要输出这个数mod10007的值。\n</div>\n<h3>\n【输入格式】\n</h3>\n<div class=\"pdcont\">\n输入的第一行包括两个正整数N和k。<br/>\n下面有N-1行，每行两个正整数u、v(1 ≤u, v≤N)，表示第u个城市和第v个城市之间有道路相连。这些道路保证能符合题目的要求。\n</div>\n<h3>\n【输出格式】\n</h3>\n<div class=\"pdcont\">\n输出共N行，每行一个正整数，第i行的正整数表示第i个城市的指标值mod10007的值。\n</div>\n<h3>\n【样例输入】\n</h3>\n<div class=\"pddata\">\n5 2<br/>\n1 2<br/>\n1 3<br/>\n2 4<br/>\n2 5\n</div>\n<h3>\n【样例输出】\n</h3>\n<div class=\"pddata\">\n10<br/>\n7<br/>\n23<br/>\n18<br/>\n18\n</div>\n<h3>\n【数据规模和约定】\n</h3>\n<div class=\"pdcont\">\n20%的数据满足N≤ 5000、k≤ 30。<br/>\n50%的数据满足N≤ 50000、k≤30。<br/>\n100%的数据满足N≤ 50000、k≤ 150。\n</div>\n<h3>\n【特别说明】\n</h3>\n<div class=\"pdcont\">\n由于数据大小限制为5MB，我只好对测试时的输入文件进行压缩处理。下面的函数可以将压缩的输入文件转化为原始输入文件。（函数从infile中读入压缩的输入文件，将解压缩后的输入文件输出到outfile中）<br/>\nC/C++版本：<br/>\nvoid Uncompress(FILE *infile, FILE *outfile)<br/>\n{<br/>\nint N, k, L, i, now, A, B, Q, tmp;<br/>\nfscanf(infile, &#34;%d%d%d&#34;, &amp;N, &amp;k, &amp;L);<br/>\nfscanf(infile, &#34;%d%d%d%d&#34;, &amp;now, &amp;A, &amp;B, &amp;Q);<br/>\nfprintf(outfile, &#34;%d %d\\n&#34;, N, k);<br/>\nfor (i = 1; i &lt; N; i ++)<br/>\n{<br/>\nnow = (now * A + B) % Q;<br/>\ntmp = (i &lt; L) ? i : L;<br/>\nfprintf(outfile, &#34;%d %d\\n&#34;, i - now % tmp, i + 1);<br/>\n}<br/>\n}<br/>\n<br/>\nPascal版本：<br/>\nprocedure Uncompress(varinfile, outfile : text);<br/>\nvar<br/>\nN, k, L, i, now, A, B, Q, tmp : longint;<br/>\nbegin<br/>\nread(infile, N, k, L, now, A, B, Q);<br/>\nwriteln(outfile, N, &#39; &#39;, k);<br/>\nfor i := 1 to N - 1 do<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\nif i &lt; L then tmp := i else tmp := L;<br/>\nwriteln(outfile, i - now mod tmp, &#39; &#39;, i + 1);<br/>\nend;<br/>\nend;<br/>\n<br/>\n下面给出一个具体的例子。civiliazation_compressed.in表示压缩的输入文件，civilization.in表示解压缩后的输入文件。<br/>\ncivilization_compressed.in<br/>\n7 26 4<br/>\n29643 2347 5431 54209<br/>\n<br/>\ncivilization.in<br/>\n7 26<br/>\n1 2<br/>\n2 3<br/>\n2 4<br/>\n3 5<br/>\n4 6<br/>\n5 7\n</div>\n</div>\n<div id=\"pcont2\" style=\"margin-top:20px;display:none;\">\n<h3>\n【问题描述】\n</h3>\n<div class=\"probcontent\">\nCrash小朋友最近迷上了一款游戏——文明5(Civilization V)。在这个游戏中，玩家可以建立和发展自己的国家，通过外交和别的国家交流，或是通过战争征服别的国家。<br/>\n现在Crash已经拥有了一个N个城市的国家，这些城市之间通过道路相连。由于建设道路是有花费的，因此Crash只修建了N-1条道路连接这些城市，不过可以保证任意两个城市都有路径相通。<br/>\n在游戏中，Crash需要选择一个城市作为他的国家的首都，选择首都需要考虑很多指标，有一个指标是这样的：<br/>\n<img width=\"160\" height=\"64\" alt=\"\" src=\"/RequireFile.do?fid=tJ72G7EF\"/><br/>\n其中S(i)表示第i个城市的指标值，dist(i, j)表示第i个城市到第j个城市需要经过的道路条数的最小值，k为一个常数且为正整数。<br/>\n因此Crash交给你一个简单的任务：给出城市之间的道路，对于每个城市，输出这个城市的指标值，由于指标值可能会很大，所以你只需要输出这个数mod10007的值。<br/>\n<br/>\n \n</div>\n<h3>\n【输入格式】\n</h3>\n<div class=\"probcontent\">\n输入的第一行包括两个正整数N和k。<br/>\n下面有N-1行，每行两个正整数u、v(1 ≤u, v≤N)，表示第u个城市和第v个城市之间有道路相连。这些道路保证能符合题目的要求。<br/>\n<br/>\n \n</div>\n<h3>\n【输出格式】\n</h3>\n<div class=\"probcontent\">\n输出共N行，每行一个正整数，第i行的正整数表示第i个城市的指标值mod10007的值。<br/>\n<br/>\n \n</div>\n<h3>\n【样例输入】\n</h3>\n<div class=\"probexample\">\n5 2<br/>\n1 2<br/>\n1 3<br/>\n2 4<br/>\n2 5<br/>\n<br/>\n \n</div>\n<h3>\n【样例输出】\n</h3>\n<div class=\"probexample\">\n10<br/>\n7<br/>\n23<br/>\n18<br/>\n18<br/>\n<br/>\n \n</div>\n<h3>\n【数据范围】\n</h3>\n<div class=\"probcontent\">\n20%的数据满足N≤ 5000、k≤ 30。<br/>\n50%的数据满足N≤ 50000、k≤30。<br/>\n100%的数据满足N≤ 50000、k≤ 150。<br/>\n<br/>\n \n</div>\n<h3>\n【特别说明】\n</h3>\n<div class=\"probcontent\">\n由于数据大小限制为5MB，我只好对测试时的输入文件进行压缩处理。下面的函数可以将压缩的输入文件转化为原始输入文件。（函数从infile中读入压缩的输入文件，将解压缩后的输入文件输出到outfile中）<br/>\nC/C++版本：<br/>\nvoid Uncompress(FILE *infile, FILE *outfile)<br/>\n{<br/>\n    int N, k, L, i, now, A, B, Q, tmp;<br/>\n    fscanf(infile, &#34;%d%d%d&#34;, &amp;N, &amp;k, &amp;L);<br/>\n    fscanf(infile, &#34;%d%d%d%d&#34;, &amp;now, &amp;A, &amp;B, &amp;Q);<br/>\n    fprintf(outfile, &#34;%d %d\\n&#34;, N, k);<br/>\n    for (i = 1; i &lt; N; i ++)<br/>\n        {<br/>\n        now = (now * A + B) % Q;<br/>\n        tmp = (i &lt; L) ? i : L;<br/>\n        fprintf(outfile, &#34;%d %d\\n&#34;, i - now % tmp, i + 1);<br/>\n        }<br/>\n}<br/>\n<br/>\nPascal版本：<br/>\nprocedure Uncompress(varinfile, outfile : text);<br/>\nvar<br/>\nN, k, L, i, now, A, B, Q, tmp : longint;<br/>\nbegin<br/>\n    read(infile, N, k, L, now, A, B, Q);<br/>\n    writeln(outfile, N, &#39; &#39;, k);<br/>\n    for i := 1 to N - 1 do<br/>\n        begin<br/>\n            now := (now * A + B) mod Q;<br/>\n            if i &lt; L then tmp := i else tmp := L;<br/>\n            writeln(outfile, i - now mod tmp, &#39; &#39;, i + 1);<br/>\n        end;<br/>\nend;<br/>\n<br/>\n下面给出一个具体的例子。civiliazation_compressed.in表示压缩的输入文件，civilization.in表示解压缩后的输入文件。<br/>\ncivilization_compressed.in <br/>\n7 26 4<br/>\n29643 2347 5431 54209<br/>\n<br/>\ncivilization.in<br/>\n7 26<br/>\n1 2<br/>\n2 3<br/>\n2 4<br/>\n3 5<br/>\n4 6<br/>\n5 7<br/>\n<br/>\n</div>\n</div>\n</div>\n\n"}]}