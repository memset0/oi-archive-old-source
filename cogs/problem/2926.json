{"title":"[USACO Open18] Out of Sorts (Gold)","time_limit":1000,"memory_limit":256,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vNxSmVPVe","statement":[{"title":"# 题目描述","format":"html","require":["katex"],"content":"\n\n<h3>\n【题目描述】\n</h3>\n<p>\n<br/>\n</p>\n<p>\n留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程网站上学习算法。\n</p>\n<p>\n她到目前为止最喜欢的算法是“冒泡排序”。这是Bessie最初的对长度为N的数组A进行排序的奶牛码实现。\n</p>\n<p>\nsorted = false\n</p>\n<p>\nwhile (not sorted):\n</p>\n<p>\n  sorted = true\n</p>\n<p>\n  moo\n</p>\n<p>\n  for i = 0 to N-2:\n</p>\n<p>\n     if A[i+1] &lt; A[i]:\n</p>\n<p>\n        swap A[i], A[i+1]\n</p>\n<p>\n        sorted = false\n</p>\n<p>\n<br/>\n</p>\n<p>\n显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie看上去执着于在她的代码中的不同位置使用这个语句。\n</p>\n<p>\n<br/>\n</p>\n<p>\n在用若干个数组测试了她的代码之后，Bessie得到一个有趣的观察现象：大的元素很快就会被拉到数组末尾，然而小的元素需要很长时间“冒泡”到数组的开头（她怀疑这就是为什么这个算法得名的原因）。为了实验和缓解这一问题，Bessie试着修改了她的代码，使代码在每次循环中向前再向后各扫描一次，从而无论是大的元素还是小的元素在每一次循环中都有机会被拉较长的一段距离。她的代码现在是这样的：\n</p>\n<p>\n<br/>\n</p>\n<p>\nsorted = false\n</p>\n<p>\nwhile (not sorted):\n</p>\n<p>\n  sorted = true\n</p>\n<p>\n  moo\n</p>\n<p>\n  for i = 0 to N-2:\n</p>\n<p>\n     if A[i+1] &lt; A[i]:\n</p>\n<p>\n        swap A[i], A[i+1]\n</p>\n<p>\n  for i = N-2 downto 0:\n</p>\n<p>\n     if A[i+1] &lt; A[i]:\n</p>\n<p>\n        swap A[i], A[i+1]\n</p>\n<p>\n  for i = 0 to N-2:\n</p>\n<p>\n     if A[i+1] &lt; A[i]:\n</p>\n<p>\n        sorted = false\n</p>\n<p>\n<br/>\n</p>\n<p>\n给定一个输入数组，请预测Bessie修改后的代码会输出多少次“moo”。\n</p>\n<p>\n<br/>\n</p>\n<h3>\n【输入格式】\n</h3>\n<p>\n<br/>\n</p>\n<p>\n输入的第一行包含N（1≤N≤100,000）。接下来N行描述了A[0]…A[N−1]，每个数都是一个范围为0…10^9的整数。输入数据不保证各不相同。\n</p>\n<p>\n<br/>\n</p>\n<h3>\n【输出格式】\n</h3>\n<p>\n输出“moo”被输出的次数。\n</p>\n<h3>\n【样例输入】\n</h3>\n<pre>5\n1\n8\n5\n3\n2\n</pre>\n<h3>\n【样例输出】\n</h3>\n<pre>2\n</pre>\n<h3>\n【数据规模】\n</h3>\n<p>\n30%的数据N&lt;=10000;\n</p>\n<p>\n100%的数据N&lt;=100000;\n</p>\n<h3>\n【来源】\n</h3>\n<p>\n<a href=\"http://www.usaco.org/index.php?page=open18results\" target=\"_blank\">USACO 2018 OPEN CONTEST</a> Gold Problem 1\n</p>\n<p>\n供题：Brian Dean\n</p>\n\n"}]}