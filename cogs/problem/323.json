{"title":"[AHOI2006] 棋盘上的问题","time_limit":10000,"memory_limit":128,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=pJmmNNjVj","statement":[{"title":"# 题目描述","format":"html","require":["katex"],"content":"\n\n<p>\n可可和卡卡画了一张巨大的 <em>N </em>* <em>N </em>的棋盘，他们想在这个棋盘上放尽量多的国际象棋的“車”，使得它们互相不能攻击到对方（車可以沿着棋盘的横向和纵向攻击）。但这个答案显然就是棋盘的宽度 <em>N </em>，于是可可在棋盘上规定了只有在有限的 <em>M </em>个位置上才能放棋子。（其他位置不能放棋子，而車却可以穿过这个位置去攻击其他的棋子）然而这样也不会难倒两个聪明的小家伙，他们很快算出来这个答案是 <em>K </em>。于是卡卡又提出来一个问题：如果我们在这 <em>M </em>个可以放棋子的位置中再去掉一个位置，而仍然保证最多能放下 <em>K </em>个車，可行的方案又有多少种呢？\n</p>\n<h3>\n[ 任务 ]\n</h3>\n<p>\n编写一个程序：\n</p>\n<p>\n•  从输入文件中读入棋盘的大小和棋盘上可以放棋子的位置信息；\n</p>\n<p>\n•  计算出如题卡卡所说的可行方案的数目；\n</p>\n<p>\n•  向输出文件打印你得到的答案。\n</p>\n<h3>\n[ 输入格式 ]\n</h3>\n<p>\n输入文件的第一行有两个正整数 <em>N </em>和 <em>M </em>，分别表示棋盘的大小和可以放棋子的位置数目。\n</p>\n<p>\n以下 <em>M </em>行，每行用 <em>x i </em>和 <em>y i </em>两个整数描述一个位置，表示这个位置是棋盘的第 <em>x i </em>行第 <em>y i </em>列 (1&lt;= <em>i </em>&lt;= <em>M </em>, 1&lt;= <em>x i </em>, <em>y i </em>&lt;= <em>N </em>) 。同样的一个位置不会被描述两次。\n</p>\n<h3>\n[ 输出格式 ]\n</h3>\n<p>\n输出文件中只有一个整数，表示可行方案的数目。\n</p>\n<h3>\n[ 输入样例 ]\n</h3>\n<p>\n3 4 <br/>\n1 2 <br/>\n1 3 <br/>\n2 2 <br/>\n2 1\n</p>\n<h3>\n[ 输出样例 ]\n</h3>\n<p>\n4\n</p>\n<h3>\n[ 数据约束和评分方法 ]\n</h3>\n<p>\n30% 的测试数据中， 1&lt;= <em>N </em>&lt;=1 000, 1&lt;= <em>M </em>&lt;=20 000\n</p>\n<p>\n100% 的测试数据中， 1&lt;= <em>N </em>&lt;=200 000, 1&lt;= <em>M </em>&lt;=600 000\n</p>\n<p>\n<br/>\n</p>\n<p>\n<strong>对 </strong><strong>C++ </strong><strong>选手的提示：经测试，对最大的测试数据使用 </strong><strong>fstream </strong><strong>进行输入有可能会比使用 </strong><strong>stdio </strong><strong>慢很多，因此建议在可以的情况下使用后者。 </strong> \n</p>\n<p>\n<strong>本题不设部分分，对于每个测试点只有当你的程序的输出和我们的标准输出完全一致时才可以得到相应的分数。 <br/>\n</strong> \n</p>\n<p>\n<strong>UPD：2017.7.12 By Mike</strong> \n</p>\n<p>\n<strong>原题应该是数据有误，我用Byvoid学长的程序，和我的跑出了相同的答案，而且和标准答案不同！此题数据已更换为我和Byvoid学长程序跑出的结果。</strong> \n</p>\n<p>\n<strong>原题时间限制是1s，如果有哪位神犇知道能在时限中跑出的方法，请给我发邮件联系，感激不尽！</strong>\n</p>\n<p>\n<strong>解决爆栈，我们加两行代码就好了：</strong>\n</p>\n<p>\n<strong>\n</strong></p><pre class=\"prettyprint lang-cpp\"><strong>int __size__=64&lt;&lt;20;\nchar *__p__=(char*)malloc(__size__)+__size__;\n__asm__(&#34;movl %0, %%esp\\n&#34;::&#34;r&#34;(__p__));</strong></pre><strong>\n小心炸内存……<br/>\n</strong> \n<p></p>\n\n"}]}