{"title":"[USACO Open18] Out of Sorts(Platinum)","time_limit":1000,"memory_limit":256,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vNzJNVPVP","statement":[{"title":"# 题目描述","format":"html","require":["katex"],"content":"\n\n<h3>\n【题目描述】\n</h3>\n<p>\n留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但是不幸的是Bessie轻易地把它们搞混了，最后实现了一个奇怪的混合算法！如果数组$A$中$A[...i]$的最大值不大于$A[i+1…]$的最小值，我们就称元素$i$和$i+1$之间的位置为一个“分隔点”。Bessie还记得快速排序包含对数组的重排，产生了一个分隔点，然后要递归对两侧的$A[...i]$和$A[i+1…]$排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内被求出，她却忘记快速排序应该怎么重排来快速构造一个分隔点了！在这个可能会被证明是排序算法的历史中最糟糕的算法性失误之下，她做出了一个不幸的决定，使用冒泡排序来完成这个任务。\n</p>\n<p>\n以下是Bessie最初的对数组$A$进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：\n</p>\n<p>\nbubble_sort_pass (A) {\n</p>\n<p>\n    for i = 0 to length(A)-2\n</p>\n<p>\n        if A[i] &gt; A[i+1], swap A[i] and A[i+1]\n</p>\n<p>\n}\n</p>\n<p>\n她的快速排序（相当快）函数的递归代码是按下面的样子构成的：\n</p>\n<p>\nquickish_sort (A) {\n</p>\n<p>\n    if length(A) = 1, return\n</p>\n<p>\n    do { // Main loop\n</p>\n<p>\n        work_counter = work_counter + length(A)\n</p>\n<p>\n        bubble_sort_pass(A)\n</p>\n<p>\n    } while (no partition points exist in A)\n</p>\n<p>\n    divide A at all partition points; recursively quickish_sort each piece\n</p>\n<p>\n}\n</p>\n<p>\nBessie好奇于她的代码能够运行得多快。简单起见，她计算出她得主循环的每一轮都消耗线性时间，所以她相应增加一个全局变量work_counter的值，以此来跟踪整个算法总共完成的工作量。\n</p>\n<p>\n给定一个输入数组，请预测quickish_sort函数接收这个数组之后，变量work_counter的最终值。\n</p>\n<h3>\n【输入格式】\n</h3>\n<p>\n输入的第一行包含$N$（$1≤N≤100,000$）。接下来$N$行描述了$A[0]…A[N−1]$，每个数都是一个范围为$0…10^9$的整数。输入数据不保证各不相同。\n</p>\n<h3>\n【输出格式】\n</h3>\n<p>\n输出work_counter的最终值。\n</p>\n<h3>\n【输入样例】\n</h3>\n<pre>7\n20\n2\n3\n4\n9\n8\n7\n</pre>\n<h3>\n【输出样例】\n</h3>\n<pre>12</pre>\n<h3>\n【提示】\n</h3>\n<p>\n在这个例子中，数组开始时为20 2 3 4 9 8 7。在一轮冒泡排序之后（增加7的工作量），我们得到2 | 3 | 4 | 9 8 7 | 20，其中|表示一个分隔点。于是我们的问题被分成了递归的子问题，包括对2、3、4、20排序（每个消耗0单元的工作量）和对9 8 7排序。对于9 8 7这个子问题，主循环的一轮（3单元工作量）得到8 7 | 9，在此之后最后一轮处理8 7（2单元工作量） 就有效地完成了排序。\n</p>\n<h3>\n【来源】\n</h3>\n<p>\nUSACO Open18 Platinum\n</p>\n<p>\n供题：Brian Dean\n</p>\n\n"}]}