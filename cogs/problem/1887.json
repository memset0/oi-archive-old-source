{"title":"[国家集训队 2011] Crash的旅行计划","time_limit":2000,"memory_limit":512,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vSJiikUUW","statement":[{"title":"题目描述","format":"html","require":["katex"],"content":"\n\n<div class=\"content\">\n<!--begin main-->\n<!-- InstanceBeginEditable name=\"content\" -->\n<h3>\n【试题来源】\n</h3>\n<div id=\"psrc\" style=\"margin-top:20px;display:block;\">\n<div class=\"pdcont\">\n2011中国国家集训队命题答辩\n</div>\n</div>\n<div id=\"pinputs\" style=\"display:none;\">\n<div class=\"pdsec\">\n输入数据\n</div>\n<div class=\"pdcont\">\n<span class=\"notice\"> 这是一道提交答案的试题，下面给出了该题的输入数据：</span> \n</div>\n<div id=\"inputlist\" class=\"pddata\">\n</div>\n</div>\n<div id=\"pcont1\" style=\"margin-top:20px;display:block;\">\n<h3>\n【问题描述】\n</h3>\n<div class=\"pdcont\">\n过不了多久，Crash就要迎来他朝思暮想的暑假。在这个暑假里，他计划着到火星上旅游。在火星上有N个旅游景点，Crash用1至N这N个正整数对这些景点标号。旅游景点之间通过双向道路相连。由于火星的环境和地球有很大的差异，建立道路的成本也相对较高。为了节约成本，只有N-1条道路连接着这些旅游景点，不过可以保证任何两个不同的旅游景点都通过路径相连。<br/>\nCrash预先在互联网上查阅了这些景点的信息，根据网上的介绍，他对每个景点都有一个印象值，这个印象值为一个整数。在这个旅行中，他会选择一个景点作为旅行的开始，并沿着存在的道路到达其他景点游玩。为了使旅行不显得乏味，Crash不会经过同一个景点超过一次。Crash还给这次旅行定义了一个快乐指数，也就是他经过的所有景点的印象值之和。<br/>\n不过Crash是个奇怪的小朋友，他对于景点的印象值会发生改变，并且他也没有决定好应该从哪个景点开始旅行。因此他希望你能写一个程序帮他完成一个简单的任务：根据当前他对每个景点的印象值，计算从某个景点开始旅行所能获得的最大的快乐指数。\n</div>\n<h3>\n【输入格式】\n</h3>\n<div class=\"pdcont\">\n输入的第一行包含一个字符和一个正整数N，字符为ABC中的一个，用来表示这个测试数据的类型（详见下面的数据规模和约定）。<br/>\n第二行包含N个用空格隔开的整数，第i个整数表示Crash对i号景点的初始印象值。<br/>\n接着有N-1行，每行两个正整数a、b(1 ≤a, b≤N)，表示从a号景点到b号景点有一条无向道路相连。<br/>\n最后是一些指令，指令只会是以下三种格式：<br/>\n1． Change ux (1 ≤u≤N)将u号景点的印象值修改为x。<br/>\n2． Query u (1 ≤u≤N) 询问从u号景点开始能获得的最大的快乐指数。<br/>\n3． Done收到这个指令后，你的程序应该结束。\n</div>\n<h3>\n【输出格式】\n</h3>\n<div class=\"pdcont\">\n对于每条Query指令，输出对应的最大快乐指数。\n</div>\n<h3>\n【样例输入】\n</h3>\n<div class=\"pddata\">\nA 6<br/>\n6 5 -4 3 -2 1<br/>\n1 2<br/>\n1 3<br/>\n1 4<br/>\n3 5<br/>\n3 6<br/>\nQuery 3<br/>\nQuery 4<br/>\nChange 6 10<br/>\nQuery 3<br/>\nChange 2 -5<br/>\nQuery 3<br/>\nQuery 4<br/>\nDone\n</div>\n<h3>\n【样例输出】\n</h3>\n<div class=\"pddata\">\n7<br/>\n14<br/>\n7<br/>\n6<br/>\n15\n</div>\n<h3>\n【样例输入】\n</h3>\n<div class=\"pddata\">\nB 5<br/>\n5 -4 3 -2 1<br/>\n1 2<br/>\n2 3<br/>\n3 4<br/>\n4 5<br/>\nQuery 3<br/>\nChange 5 10<br/>\nQuery 3<br/>\nQuery 2<br/>\nChange 2 2<br/>\nQuery 3<br/>\nDone\n</div>\n<h3>\n【样例输出】\n</h3>\n<div class=\"pddata\">\n4<br/>\n11<br/>\n7<br/>\n11\n</div>\n<h3>\n【数据规模和约定】\n</h3>\n<div class=\"pdcont\">\n测试数据分为ABC三类，对于所有的测试数据都满足：在任何时候一个景点印象值的绝对值不超过10000，并且输入的道路一定能满足题目描述的要求，即使得任意两个不同的景点都能通过路径相连。<br/>\n对于A类数据（占20%的分数）满足：N和指令的条数都不超过1000。<br/>\n对于B类数据（占40%的分数）满足：N和指令的条数都不超过100000，且输入的第i条道路，连接着i号景点和i+1号景点（详见样例2）。<br/>\n对于C类数据（占40%的分数）满足：N和指令的条数都不超过100000，且任何一个景点到1号景点需要通过的道路条数不超过40。\n</div>\n<h3>\n【特别说明】\n</h3>\n<div class=\"pdcont\">\n由于数据大小限制为5MB，我只好对测试时的输入文件进行压缩处理。下面的函数可以将压缩的输入文件转化为原始输入文件。（函数从infile中读入压缩的输入文件，将解压缩后的输入文件输出到outfile中）<br/>\nC/C++版本：<br/>\nvoid Uncompress(FILE *infile, FILE *outfile)<br/>\n{<br/>\nint N, M, L, now, A, B, Q, tmp, i;<br/>\nchar type = getc(infile);<br/>\nfscanf(infile, &#34;%d%d%d&#34;, &amp;N, &amp;M, &amp;L);<br/>\nfscanf(infile, &#34;%d%d%d%d&#34;, &amp;now, &amp;A, &amp;B, &amp;Q);<br/>\nfprintf(outfile, &#34;%c %d\\n&#34;, type, N);<br/>\nfor (i = 1; i &lt;= N; i ++)<br/>\n{<br/>\nnow = (now * A + B) % Q, tmp = now % 10000;<br/>\nnow = (now * A + B) % Q;<br/>\nif (now * 2 &lt; Q) tmp *= -1;<br/>\nif (i &lt; N)<br/>\nfprintf(outfile, &#34;%d &#34;, tmp);<br/>\nelse<br/>\nfprintf(outfile, &#34;%d\\n&#34;, tmp);<br/>\n}<br/>\nfor (i = 1; i &lt; N; i ++)<br/>\n{<br/>\nnow = (now * A + B) % Q;<br/>\ntmp = (i &lt; L) ? i : L;<br/>\nfprintf(outfile, &#34;%d %d\\n&#34;, i - now % tmp, i + 1);<br/>\n}<br/>\nfor (i = 1; i &lt; M; i ++)<br/>\n{<br/>\nnow = (now * A + B) % Q;<br/>\nif (now * 3 &lt; Q)<br/>\n{<br/>\nnow = (now * A + B) % Q;<br/>\nfprintf(outfile, &#34;Query %d\\n&#34;, now % N + 1);<br/>\n}<br/>\nelse<br/>\n{<br/>\nnow = (now * A + B) % Q, tmp = now % 10000;<br/>\nnow = (now * A + B) % Q;<br/>\nif (now * 2 &lt; Q) tmp *= -1;<br/>\nnow = (now * A + B) % Q;<br/>\nfprintf(outfile, &#34;Change %d %d\\n&#34;, now % N + 1, tmp);<br/>\n}<br/>\n}<br/>\nfprintf(outfile, &#34;Done\\n&#34;);<br/>\n}<br/>\n<br/>\nPascal版本：<br/>\nprocedure Uncompress(varinfile, outfile : text);<br/>\nvar<br/>\nN, M, L, now, A, B, Q, tmp, i : longint;<br/>\nch : char;<br/>\nbegin<br/>\nread(infile, ch, N, M, L, now, A, B, Q);<br/>\nwriteln(outfile, ch, &#39; &#39;, N);<br/>\nfor i := 1 to N do<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\ntmp := now mod 10000;<br/>\nnow := (now * A + B) mod Q;<br/>\nif now * 2 &lt; Q then tmp := -tmp;<br/>\nif i &lt; n then<br/>\nwrite(outfile, tmp, &#39; &#39;)<br/>\nelse<br/>\nwriteln(outfile, tmp);<br/>\nend;<br/>\nfor i := 1 to N - 1 do<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\nif i &lt; L then tmp := i else tmp := L;<br/>\nwriteln(outfile, i - now mod tmp, &#39; &#39;, i + 1);<br/>\nend;<br/>\nfor i := 1 to M - 1 do<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\nif now * 3 &lt; Q then<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\nwriteln(outfile, &#39;Query &#39;, now mod N + 1);<br/>\nend<br/>\nelse<br/>\nbegin<br/>\nnow := (now * A + B) mod Q;<br/>\ntmp := now mod 10000;<br/>\nnow := (now * A + B) mod Q;<br/>\nif now * 2 &lt; Q then tmp := -tmp;<br/>\nnow := (now * A + B) mod Q;<br/>\nwriteln(outfile, &#39;Change &#39;, now mod N + 1, &#39; &#39;, tmp);<br/>\nend;<br/>\nend;<br/>\nwriteln(outfile, &#39;Done&#39;);<br/>\nend;<br/>\n<br/>\n下面给出一个具体的例子。travel_compressed.in表示压缩的输入文件，travel.in表示解压缩后的输入文件。<br/>\ntravel_compressed.in<br/>\nA 5 7 3<br/>\n17627 543 14278 380043<br/>\n<br/>\ntravel.in<br/>\nA 5<br/>\n-4664 7653 -3584 -210 5852<br/>\n1 2<br/>\n1 3<br/>\n2 4<br/>\n3 5<br/>\nChange 5 -3724<br/>\nQuery 4<br/>\nChange 3 -5628<br/>\nQuery 2<br/>\nChange 5 569<br/>\nQuery 5<br/>\nDone\n</div>\n</div>\n<div id=\"pcont2\" style=\"margin-top:20px;display:none;\">\n<h3>\n【问题描述】\n</h3>\n<div class=\"probcontent\">\n过不了多久，Crash就要迎来他朝思暮想的暑假。在这个暑假里，他计划着到火星上旅游。在火星上有N个旅游景点，Crash用1至N这N个正整数对这些景点标号。旅游景点之间通过双向道路相连。由于火星的环境和地球有很大的差异，建立道路的成本也相对较高。为了节约成本，只有N-1条道路连接着这些旅游景点，不过可以保证任何两个不同的旅游景点都通过路径相连。<br/>\nCrash预先在互联网上查阅了这些景点的信息，根据网上的介绍，他对每个景点都有一个印象值，这个印象值为一个整数。在这个旅行中，他会选择一个景点作为旅行的开始，并沿着存在的道路到达其他景点游玩。为了使旅行不显得乏味，Crash不会经过同一个景点超过一次。Crash还给这次旅行定义了一个快乐指数，也就是他经过的所有景点的印象值之和。<br/>\n不过Crash是个奇怪的小朋友，他对于景点的印象值会发生改变，并且他也没有决定好应该从哪个景点开始旅行。因此他希望你能写一个程序帮他完成一个简单的任务：根据当前他对每个景点的印象值，计算从某个景点开始旅行所能获得的最大的快乐指数。<br/>\n<br/>\n \n</div>\n<h3>\n【输入格式】\n</h3>\n<div class=\"probcontent\">\n输入的第一行包含一个字符和一个正整数N，字符为ABC中的一个，用来表示这个测试数据的类型（详见下面的数据规模和约定）。<br/>\n第二行包含N个用空格隔开的整数，第i个整数表示Crash对i号景点的初始印象值。<br/>\n接着有N-1行，每行两个正整数a、b(1 ≤a, b≤N)，表示从a号景点到b号景点有一条无向道路相连。<br/>\n最后是一些指令，指令只会是以下三种格式：<br/>\n1． Change ux (1 ≤u≤N)将u号景点的印象值修改为x。<br/>\n2． Query u (1 ≤u≤N) 询问从u号景点开始能获得的最大的快乐指数。<br/>\n3． Done收到这个指令后，你的程序应该结束。<br/>\n<br/>\n \n</div>\n<h3>\n【输出格式】\n</h3>\n<div class=\"probcontent\">\n对于每条Query指令，输出对应的最大快乐指数。<br/>\n<br/>\n \n</div>\n<h3>\n【样例输入1】\n</h3>\n<div class=\"probexample\">\nA 6<br/>\n6 5 -4 3 -2 1<br/>\n1 2<br/>\n1 3<br/>\n1 4<br/>\n3 5<br/>\n3 6<br/>\nQuery 3<br/>\nQuery 4<br/>\nChange 6 10<br/>\nQuery 3<br/>\nChange 2 -5<br/>\nQuery 3<br/>\nQuery 4<br/>\nDone<br/>\n<br/>\n \n</div>\n<h3>\n【样例输出1】\n</h3>\n<div class=\"probexample\">\n7<br/>\n14<br/>\n7<br/>\n6<br/>\n15<br/>\n<br/>\n \n</div>\n<h3>\n【样例输入2】\n</h3>\n<div class=\"probexample\">\nB 5<br/>\n5 -4 3 -2 1<br/>\n1 2<br/>\n2 3<br/>\n3 4<br/>\n4 5<br/>\nQuery 3<br/>\nChange 5 10<br/>\nQuery 3<br/>\nQuery 2<br/>\nChange 2 2<br/>\nQuery 3<br/>\nDone<br/>\n<br/>\n \n</div>\n<h3>\n【样例输出2】\n</h3>\n<div class=\"probexample\">\n4<br/>\n11<br/>\n7<br/>\n11<br/>\n<br/>\n \n</div>\n<h3>\n【数据范围】\n</h3>\n<div class=\"probcontent\">\n测试数据分为ABC三类，对于所有的测试数据都满足：在任何时候一个景点印象值的绝对值不超过10000，并且输入的道路一定能满足题目描述的要求，即使得任意两个不同的景点都能通过路径相连。<br/>\n对于A类数据（占20%的分数）满足：N和指令的条数都不超过1000。<br/>\n对于B类数据（占40%的分数）满足：N和指令的条数都不超过100000，且输入的第i条道路，连接着i号景点和i+1号景点（详见样例2）。<br/>\n对于C类数据（占40%的分数）满足：N和指令的条数都不超过100000，且任何一个景点到1号景点需要通过的道路条数不超过40。<br/>\n<br/>\n \n</div>\n<h3>\n【特别说明】\n</h3>\n<div class=\"probcontent\">\n由于数据大小限制为5MB，我只好对测试时的输入文件进行压缩处理。下面的函数可以将压缩的输入文件转化为原始输入文件。（函数从infile中读入压缩的输入文件，将解压缩后的输入文件输出到outfile中）<br/>\nC/C++版本：<br/>\nvoid Uncompress(FILE *infile, FILE *outfile)<br/>\n{<br/>\n    int N, M, L, now, A, B, Q, tmp, i;<br/>\n    char type = getc(infile);<br/>\n    fscanf(infile, &#34;%d%d%d&#34;, &amp;N, &amp;M, &amp;L);<br/>\n    fscanf(infile, &#34;%d%d%d%d&#34;, &amp;now, &amp;A, &amp;B, &amp;Q);<br/>\n    fprintf(outfile, &#34;%c %d\\n&#34;, type, N);<br/>\n    for (i = 1; i &lt;= N; i ++)<br/>\n    {<br/>\n        now = (now * A + B) % Q, tmp = now % 10000;<br/>\n        now = (now * A + B) % Q;<br/>\n        if (now * 2 &lt; Q) tmp *= -1;<br/>\n        if (i &lt; N)<br/>\n            fprintf(outfile, &#34;%d &#34;, tmp);<br/>\n        else<br/>\n        fprintf(outfile, &#34;%d\\n&#34;, tmp);<br/>\n    }<br/>\n    for (i = 1; i &lt; N; i ++)<br/>\n    {<br/>\n        now = (now * A + B) % Q;<br/>\n        tmp = (i &lt; L) ? i : L;<br/>\n        fprintf(outfile, &#34;%d %d\\n&#34;, i - now % tmp, i + 1);<br/>\n    }<br/>\n    for (i = 1; i &lt; M; i ++)<br/>\n    {<br/>\n        now = (now * A + B) % Q;<br/>\n        if (now * 3 &lt; Q)<br/>\n        {<br/>\n            now = (now * A + B) % Q;<br/>\n            fprintf(outfile, &#34;Query %d\\n&#34;, now % N + 1);<br/>\n        }<br/>\n        else<br/>\n        {<br/>\n            now = (now * A + B) % Q, tmp = now % 10000;<br/>\n            now = (now * A + B) % Q;<br/>\n            if (now * 2 &lt; Q) tmp *= -1;<br/>\n            now = (now * A + B) % Q;<br/>\n            fprintf(outfile, &#34;Change %d %d\\n&#34;, now % N + 1, tmp);<br/>\n        }<br/>\n    }<br/>\n    fprintf(outfile, &#34;Done\\n&#34;);<br/>\n}<br/>\n<br/>\nPascal版本：<br/>\nprocedure Uncompress(varinfile, outfile : text);<br/>\nvar<br/>\nN, M, L, now, A, B, Q, tmp, i : longint;<br/>\nch : char;<br/>\nbegin<br/>\n    read(infile, ch, N, M, L, now, A, B, Q);<br/>\n    writeln(outfile, ch, &#39; &#39;, N);<br/>\n    for i := 1 to N do<br/>\n        begin<br/>\n            now := (now * A + B) mod Q;<br/>\n            tmp := now mod 10000;<br/>\n            now := (now * A + B) mod Q;<br/>\n            if now * 2 &lt; Q then tmp := -tmp;<br/>\n            if i &lt; n then<br/>\n                write(outfile, tmp, &#39; &#39;)<br/>\n            else<br/>\n                writeln(outfile, tmp);<br/>\n        end;<br/>\n    for i := 1 to N - 1 do<br/>\n        begin<br/>\n            now := (now * A + B) mod Q;<br/>\n            if i &lt; L then tmp := i else tmp := L;<br/>\n            writeln(outfile, i - now mod tmp, &#39; &#39;, i + 1);<br/>\n        end;<br/>\n    for i := 1 to M - 1 do<br/>\n        begin<br/>\n            now := (now * A + B) mod Q;<br/>\n            if now * 3 &lt; Q then<br/>\n                begin<br/>\n                    now := (now * A + B) mod Q;<br/>\n                    writeln(outfile, &#39;Query &#39;, now mod N + 1);<br/>\n                end<br/>\n            else<br/>\n                begin<br/>\n                    now := (now * A + B) mod Q;<br/>\n                    tmp := now mod 10000;<br/>\n                    now := (now * A + B) mod Q;<br/>\n                    if now * 2 &lt; Q then tmp := -tmp;<br/>\n                    now := (now * A + B) mod Q;<br/>\n                    writeln(outfile, &#39;Change &#39;, now mod N + 1, &#39; &#39;, tmp);<br/>\n                end;<br/>\n        end;<br/>\n    writeln(outfile, &#39;Done&#39;);<br/>\nend;<br/>\n<br/>\n下面给出一个具体的例子。travel_compressed.in表示压缩的输入文件，travel.in表示解压缩后的输入文件。<br/>\ntravel_compressed.in<br/>\nA 5 7 3<br/>\n17627 543 14278 380043<br/>\n<br/>\ntravel.in<br/>\nA 5<br/>\n-4664 7653 -3584 -210 5852<br/>\n1 2<br/>\n1 3<br/>\n2 4<br/>\n3 5<br/>\nChange 5 -3724<br/>\nQuery 4<br/>\nChange 3 -5628<br/>\nQuery 2<br/>\nChange 5 569<br/>\nQuery 5<br/>\nDone<br/>\n<br/>\n<p>\n \n</p>\n</div>\n<p>\n \n</p>\n</div>\n</div>\n\n"}]}