{"title":"[SPOJ 1182] 二进制列排序","time_limit":1000,"memory_limit":256,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vxzXJkeVV","statement":[{"title":"题目描述","format":"html","require":["katex"],"content":"\n\n<h3>\n【题目描述】\n</h3>\n<p>\n让我们考虑m到n（含m,n）的所有整数i的32位二进制表示（m&lt;=i&lt;=n,m*n&gt;=0,-2^31&lt;=m&lt;=n&lt;=2^31-1）。注意，负数由32位补码表示。也就是说，一个负数的二进制表示与其相反数的二进制表示之和恰好等于2^32（二进制的1 0000 0000 0000 0000 0000 0000 0000 0000）\n</p>\n<p>\n例如，6的32位二进制表示是0000 0000 0000 0000 0000 0000 0000 0110\n</p>\n<p>\n-6的32位二进制表示是1111 1111 1111 1111 1111 1111 1111 1010\n</p>\n<p>\n因为\n</p>\n<p>\n<br/>\n</p>\n<p>\n0000 0000 0000 0000 0000 0000 0000 0110 (6)\n</p>\n<p>\n+\n</p>\n<p>\n1111 1111 1111 1111 1111 1111 1111 1010 (-6)\n</p>\n<p>\n-------------------------------------------------\n</p>\n<p>\n= 1 0000 0000 0000 0000 0000 0000 0000 0000 (2^32)\n</p>\n<p>\n<br/>\n</p>\n<p>\n让我们将这些整数的32位二进制表示排序。排序方法是：先按照二进制表示中1的个数从小到大排，1的个数相同的32位二进制数按字典序排。注意，它们的长度都是32位。\n</p>\n<p>\n例如，当m=0,n=5时，排序的结果如下：\n</p>\n<p>\n<img src=\"/upload/image/20140507/20140507230927_70745.png\" alt=\"\"/> \n</p>\n<p>\n<br/>\n</p>\n<p>\n当m=-5,n=-2时，排序的结果如下：\n</p>\n<p>\n<br/>\n</p>\n<p>\n<img src=\"/upload/image/20140507/20140507231003_71150.png\" alt=\"\"/> \n</p>\n<p>\n<br/>\n</p>\n<p>\n给出m，n，k（1&lt;=k&lt;=n-m+1），你的任务是写一个程序找到排序后m~n的整数中第k小的数。\n</p>\n<h3>\n【输入格式】\n</h3>\n<p>\n输入包含多组数据。\n</p>\n<p>\n输入文件的第一行是一个不超过1000的正整数，代表数据组数。\n</p>\n<p>\n接下来是若干组数据。\n</p>\n<p>\n每组数据有一行3个空格隔开的整数m,n,k。数据范围见题目描述。\n</p>\n<h3>\n【输出格式】\n</h3>\n<p>\n对每组数据，输出排序后第k小的数。\n</p>\n<h3>\n【样例输入】\n</h3>\n<pre>2\n0 5 3\n-5 -2 2</pre>\n<h3>\n【样例输出】\n</h3>\n<pre>2\n-5</pre>\n<h3>\n【提示】\n</h3>\n<p>\n原题中k&lt;=2147473547，但这里的k值有可能大于这个数。\n</p>\n<h3>\n【来源】\n</h3>\n<p>\n<a href=\"http://www.spoj.com/problems/SORTBIT/\" target=\"_blank\">SPOJ 1128 Sorted bit squence</a> \n</p>\n<p>\nACM ICPC 2006, Asia Regional Contest, site Hanoi\n</p>\n\n"}]}