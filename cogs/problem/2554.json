{"title":"[福利]可持久化线段树","time_limit":3000,"memory_limit":256,"url":"http://cogs.pro:8080/cogs/problem/problem.php?pid=vzXSiVggq","statement":[{"title":"题目描述","format":"html","require":["katex"],"content":"\n\n<h3>\n【题目描述】<br/>\n</h3>\n<p>\n为什么说本题是福利呢？因为这是一道非常直白的可持久化线段树的练习题，目的并不是虐人，而是指导你入门可持久化数据结构。\n</p>\n<p>\n线段树有个非常经典的应用是处理RMQ问题，即区间最大/最小值询问问题。现在我们把这个问题可持久化一下:\n</p>\n<p>\nQ k l r 查询数列在第k个版本时，区间[l, r]上的最大值\n</p>\n<p>\nM k p v 把数列在第k个版本时的第p个数修改为v，并产生一个新的数列版本\n</p>\n<p>\n最开始会给你一个数列，作为第1个版本。\n</p>\n<p>\n每次M操作会导致产生一个新的版本。修改操作可能会很多呢，如果每次都记录一个新的数列，空间和时间上都是令人无法承受的。所以我们需要可持久化数据结构:\n</p>\n<p>\n<img alt=\"\" src=\"/upload/image/20161116/20161116151606_65054.jpg\"/> \n</p>\n<p>\n对于最开始的版本1，我们直接建立一颗线段树，维护区间最大值。\n</p>\n<p>\n修改操作呢？我们发现，修改只会涉及从线段树树根到目标点上一条树链上logn个节点而已，其余的节点并不会受到影响。所以对于每次修改操作，我们可以只重建修改涉及的节点即可。就像这样:\n</p>\n<p>\n<img alt=\"\" src=\"/upload/image/20161116/20161116151646_11588.png\"/> \n</p>\n<p>\n需要查询第k个版本的最大值，那就从第k个版本的树根开始，像查询普通的线段树一样查询即可。\n</p>\n<p>\n要计算好所需空间哦\n</p>\n<h3>\n【输入格式】\n</h3>\n<p>\n第一行两个整数N, Q。N是数列的长度，Q表示询问数\n</p>\n<p>\n第二行N个整数，是这个数列\n</p>\n<p>\n之后Q行，每行以0或者1开头，0表示查询操作Q，1表示修改操作M，格式为\n</p>\n<p>\n0 k l r 查询数列在第k个版本时，区间[l, r]上的最大值 或者\n</p>\n<p>\n1 k p v 把数列在第k个版本时的第p个数修改为v，并产生一个新的数列版本\n</p>\n<h3>\n【输出格式】\n</h3>\n<p>\n对于每个M询问，输出正确答案\n</p>\n<h3>\n【样例输入】<br/>\n</h3>\n<p>\n4 5\n</p>\n<p>\n1 2 3 4\n</p>\n<p>\n0 1 1 4\n</p>\n<p>\n1 1 3 5\n</p>\n<p>\n0 2 1 3\n</p>\n<p>\n0 2 4 4\n</p>\n<p>\n0 1 2 4\n</p>\n<h3>\n【样例输出】\n</h3>\n<p>\n4\n</p>\n<p>\n5\n</p>\n<p>\n4\n</p>\n<p>\n4\n</p>\n<h3>\n【提示】\n</h3>\n<h1>\n样例解释\n</h1>\n<p>\n序列版本1: 1 2 3 4\n</p>\n<p>\n查询版本1的[1, 4]最大值为4\n</p>\n<p>\n修改产生版本2: 1 2 5 4\n</p>\n<p>\n查询版本2的[1, 3]最大值为5\n</p>\n<p>\n查询版本1的[4, 4]最大值为4\n</p>\n<p>\n查询版本1的[2, 4]最大值为4\n</p>\n<h1>\n数据范围\n</h1>\n<p>\nN &lt;= 10000 Q &lt;= 100000\n</p>\n<p>\n对于每次询问操作的版本号k保证合法，\n</p>\n<p>\n区间[l, r]一定满足1 &lt;= l &lt;= r &lt;= N\n</p>\n<h3>\n【来源】\n</h3>\n<p>\nlj出题人: sxysxy。原题见: http://syzoj.com/problem/247\n</p>\n\n"}]}